
# AI 零代码应用生成项目后期为什么要引入 LangGraph4j 来构建 AI 工作流？和之前的方式相比，解决了什么问题？

项目后期引入 `LangGraph4j` 来构建 AI 工作流，主要是为了解决直接调用 AI Service 模式下存在的流程不可控、任务耦合度高和扩展性差的问题，提升复杂任务的稳定性和可维护性。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/gftXyKhY_1755762605413-33ebd390-5157-450e-bca1-d45bfc970c59_mianshiya.png)

之前直接调用 AI Service 的方式，虽然能完成任务，但存在痛点：

-   流程黑盒与随机性：整个代码生成过程被封装在单一的 AI 调用中，很难干预中间过程。比如，我希望 AI 在生成代码前，先去搜集一些真实的图片素材，但 AI 可能会忘记或选择不执行这个步骤，导致生成结果的随机性很大。
-   任务耦合：如果像搜集图片、增强提示词、生成代码、质量检查这些逻辑上独立的步骤，都被耦合在一个巨大的提示词里，让 AI 一次性完成。这不仅使得提示词变得异常复杂和难以维护，也增加了 AI 理解和执行任务的难度。
-   扩展和优化困难：如果想在流程中增加一个新的步骤，比如 “代码质量检查不通过则返回重试”，在单一 AI Service 模式下几乎无法实现。只能寄希望于优化提示词，但是可能效果不佳且不稳定。

引入 `LangGraph4j` 工作流后，这些问题得到了很好的解决：

-   工作流将一个复杂的任务分解为一系列明确的、可控的节点和边。我可以强制规定任务必须按照图片收集 -> 提示词增强 -> 代码生成 -> 质量检查的顺序执行，将黑盒流程变成了白盒的、标准化的流程，极大地降低了随机性。
-   每个节点只负责一个单一的、具体的任务。比如，图片收集节点只关心如何获取图片，代码生成节点只关心如何生成代码。这样每个节点的逻辑都更简单、更内聚，易于开发、测试和维护。
-   高度的可扩展性与灵活性：`LangGraph4j` 支持条件边和循环。我可以轻松地实现 “如果质量检查失败，就回到代码生成节点重试” 这样的复杂逻辑。未来如果想增加新步骤，只需定义一个新的节点并将其接入到工作流图中即可，对现有流程的侵入性极小。

![](https://pic.code-nav.cn/mianshiya/question_picture/markdown/yAwnyRJ2_202508221400391_mianshiya.png)
