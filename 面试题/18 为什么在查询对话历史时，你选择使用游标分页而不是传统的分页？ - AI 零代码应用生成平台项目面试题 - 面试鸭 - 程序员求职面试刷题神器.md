
# 为什么在查询对话历史时，你选择使用游标分页而不是传统的分页？

在查询对话历史这类实时性强、数据可能频繁变动的场景下，我选择使用游标分页，主要是为了解决传统 `limit offset` 分页带来的数据一致性和性能两大问题。

1）数据一致性问题：传统的 `limit offset` 分页是基于数据行的位置偏移来获取数据的。在一个活跃的对话中，如果用户正在加载第二页历史记录时，又有新消息插入到数据库的开头，会导致数据整体下移。这样，用户请求的第二页数据可能会包含第一页已经看过的消息，造成数据重复；反之，如果删除了消息，则可能导致用户错过某些记录。

游标分页通过使用一个稳定不变的参照点（即游标），比如上一页最后一条消息的创建时间 `createTime`，来获取下一页数据（`WHERE createTime < '游标值'`），避免了这个问题。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/xkMsjY1U_1753773321162-3a635a77-f108-4d16-b85e-ad06e06bef67_mianshiya.png)

2）性能问题：当对话历史数据量非常大时，`limit offset` 分页的性能会急剧下降。比如，查询 `LIMIT 10000, 10` 时，数据库需要先扫描并跳过前面的 10000 条记录，才能找到需要返回的10条数据，这个开销非常大。游标分页的查询 `WHERE createTime < '游标值' ORDER BY createTime DESC LIMIT 10`，可以利用索引直接定位到游标所在的位置，然后顺序读取 10 条记录，查询性能非常高且稳定，不会随着页数的增加而变慢。

综上，考虑到对话历史的业务特性，使用游标分页是更优的选择，它能提供更准确、更高效的数据加载体验。
