
# 什么是 ARMS？如何利用 ARMS 实现系统监控？它主要监控了哪些指标？

ARMS 是阿里云提供的应用实时监控服务，采用了探针技术，**能够在不修改应用代码的情况下**，自动收集和分析应用性能数据，快速构建实时的监控能力。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/DwTALKsM_1755783662222-715836e9-c4f2-4aa4-8cd6-ebc40bd7fbe0_mianshiya.png)

ARMS 的接入过程非常简单，完全不需要修改任何业务代码，它的核心是 Java Agent 探针技术。

我们只需在应用的启动命令中，通过 `-javaagent` 参数挂载 ARMS 提供的探针 JAR 包，并配置好应用的唯一 License Key 和名称。应用启动时，JVM 会加载这个探针，它会自动通过字节码增强技术，在关键的方法前后动态注入监控代码。这些监控代码会收集性能数据，并将其上报到 ARMS 控制台，实现了对应用的全面监控。

ARMS 为我们提供了开箱即用的、多维度的监控视图，主要覆盖了以下几类关键指标：

1）应用性能指标：

-   接口监控：自动发现并监控所有 Spring MVC 接口的请求数、错误率、平均耗时，以及 P50/P99 等响应时间百分位数。
-   调用链追踪：记录单个请求在系统内部的完整调用链路，清晰地展示请求从进入 Controller 到访问数据库、缓存、外部 AI 模型的每一步耗时，是定位性能瓶颈的利器。
-   异常分析：自动捕获并聚合应用中的所有异常，提供详细的堆栈信息，方便快速定位错误根源。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/QyogyZXx_1754925074445-1eaa6b6b-595a-4a7a-8b7c-fdf603f5e456_mianshiya.png)

2）外部依赖监控：

-   数据库调用：监控所有 SQL 查询的执行次数、耗时，并能自动识别和告警慢 SQL。
-   NoSQL 调用：监控对 Redis 的调用情况，包括操作命令、耗时等。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/JPdONHqH_1754924642853-e390c508-d9fe-4621-9af7-01594f636295_mianshiya.png)

3）JVM 和系统资源监控：

-   JVM 监控：深入监控 JVM 的内部状态，包括堆内存使用情况、GC（垃圾回收）频率与耗时、线程数和线程池状态等。
-   系统资源：监控服务器的 CPU 使用率、内存占用、磁盘 I/O 和网络流量等基础设施指标。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/MvN20IhM_1754925652119-aad032ed-49b6-4c2c-a62a-7c43337b7175_mianshiya.png)


---


# 为什么除了 ARMS，你还需要引入 Prometheus 和 Grafana？这两套监控方案有什么不同？

我引入 Prometheus 和 Grafana 作为 ARMS 的补充，是因为这两套方案在监控目标和灵活性上有着本质的不同，它们分别解决了不同层面的可观测性需求。

ARMS 专注于通用的系统和应用性能监控，它的强项在于通过探针技术，自动地、无侵入地监控那些对于任何 Java 应用都普遍适用的性能指标，比如接口耗时、SQL 查询性能、JVM 状态、CPU 使用率等。它的目标是帮助我们快速了解系统运行得怎么样，快速发现通用的性能瓶颈和异常。

Prometheus + Grafana 专注于自定义的业务指标监控，监控那些与我们平台核心业务逻辑紧密相关的、ARMS 无法自动感知的指标。比如：

-   哪个模型被调用得最多？
-   哪个用户、哪个应用消耗的Token最多？
-   不同模型的调用成功率分别是多少？
-   哪些用户是平台的高频使用者？

这些指标需要我们通过在业务代码中手动埋点来采集。Prometheus 负责高效地存储这些时序数据，而 Grafana 则负责将这些数据以丰富的图表和仪表盘进行可视化展示，这两套方案的关系是互补的，同时使用这两套方案，我构建了一套从底层系统到上层业务的全方位、立体化的可观测性体系。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/xhxU4uvI_1755099021246-329ed3d8-b29c-4511-9cb1-0023058a933f_mianshiya.png)


---


# 你如何在 AI 项目中实现自定义业务指标的监控？

我的业务指标监控方案是基于业界主流的 Prometheus + Grafana 技术栈构建的，并通过在应用代码中进行手动埋点来实现数据的精细化采集。整个方案遵循 **采集-存储-展示** 的经典监控流程。

1）采集

我使用了 `Micrometer` 这个指标采集门面库，它集成在 Spring Boot Actuator 中。Micrometer 提供了一套统一的 API 来定义和记录指标，并且能够将这些指标转换为多种监控系统所需的格式，其中就包括 Prometheus。

我创建了一个 `AiModelMetricsCollector` 类，在其中使用 Micrometer API 定义了我们关心的核心业务指标，主要包括：

-   `Counter`：用于统计累计值，如 AI 请求总数、Token 消耗总量、错误总数。
-   `Timer`：用于记录耗时分布，如 AI 响应时长。

利用 LangChain4j 框架提供的 `ChatModelListener` 监听器接口，创建了 `AiModelMonitorListener`。这个监听器会在 AI 调用的 `onRequest`, `onResponse`, `onError` 等关键生命周期节点被触发，然后调用 `AiModelMetricsCollector` 来实时记录上述定义的指标数据。

Spring Boot Actuator 会自动创建一个 `/actuator/prometheus` 端点，将 Micrometer 采集的所有指标以 Prometheus 要求的文本格式暴露出来。

2）存储

我部署了一个独立的 Prometheus 服务，并在它的配置文件中添加了一个抓取任务，让它定期来拉取后端应用暴露的 `/actuator/prometheus` 端点的数据。Prometheus 会将这些时序数据高效地存储在它内置的 TSDB 时序数据库中。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/ZK7U8JbI_1754975743800-29954d3b-80e4-457f-85fb-5bb75a1abd8c_mianshiya.png)

3）展示

我在 Grafana 中创建了一个自定义的监控仪表盘，通过编写 PromQL 查询语句，将存储在 Prometheus 中的原始指标数据聚合成有意义的可视化图表，比如：

-   模型调用趋势图
-   Token 消耗速率图
-   Top 10 Token 消耗用户排行

因为一个个搭建图表费时费力，所以我采用了一种更高效的方式：让 AI 帮我生成完整的看板 JSON 配置。需要给 AI 提供需求说明、数据样例和 Grafana 官方的 JSON 规范。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/kGStaQ5z_1755099021246-329ed3d8-b29c-4511-9cb1-0023058a933f_mianshiya.png)


---


# AI 零代码应用生成项目中，微服务架构主要有哪些模块？介绍每个模块的作用？

基于微服务拆分原则，我将系统划分为以下模块：

**1）通用模块**

这些模块不是独立的服务，而是被其他服务依赖的公共组件：

-   yu-ai-code-common：包含所有服务公用的代码，如异常处理、工具类、常量定义等，为其他服务提供基础设施支持。
-   yu-ai-code-model：统一的数据模型定义，包含实体类、DTO、VO、枚举类等，确保各服务间数据格式的一致性。
-   yu-ai-code-client：定义需要内部调用的服务接口，作为服务间通信的契约，实现服务间的松耦合。

**2）业务服务**

这些是真正的微服务，（原则上来说）每个服务都有独立的进程和端口：

-   用户服务：作为整个系统的基础，统一管理用户状态和权限。负责用户注册、登录、注销、权限验证等核心功能。**由于几乎所有业务都需要用户信息，所以用户服务是其他服务的基础依赖。**
-   应用服务：业务核心服务，负责应用的完整生命周期管理。包括应用创建、编辑、删除、对话历史、代码保存、项目下载等功能，集成了文件操作、缓存管理、限流控制等能力。
-   AI 服务：专门处理代码生成相关功能，集成 LangChain4j 支持流式响应。包含 AI 模型调用、代码生成功能。
-   截图服务：独立的 IO 密集型服务，使用 Selenium WebDriver 进行网页截图。由于截图操作比较消耗 CPU 和内存资源，独立部署便于单独优化和扩展。

为了更好地指导实现，我还专门列了一个微服务划分表格：

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/cvHj1sSz_1755784057845-c4d6d7fc-76e3-45c4-9b3d-e4ce5de5a270_mianshiya.png)


---


# 描述 AI 零代码应用生成项目前端的核心业务流程，以及如何实现？

-   [
    
    AI 零代码应用生成项目中，如何为 AI 对话接口实现限流？解释一下原理？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776241221828610)
-   [
    
    什么是可观测性？为什么需要为 AI 项目构建一套可观测性体系？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776241502846977)
-   [
    
    什么是 ARMS？如何利用 ARMS 实现系统监控？它主要监控了哪些指标？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776241783865346)
-   [
    
    为什么除了 ARMS，你还需要引入 Prometheus 和 Grafana？这两套监控方案有什么不同？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776242077466625)
-   [
    
    你如何在 AI 项目中实现自定义业务指标的监控？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776242392039425)
-   [
    
    AI 零代码应用生成项目中，微服务架构主要有哪些模块？介绍每个模块的作用？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776242719195138)
-   [
    
    描述 AI 零代码应用生成项目前端的核心业务流程，以及如何实现？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776243348340737)
-   [
    
    前端如何处理与后端的 SSE 流式通信，并实时展示 AI 的打字机效果？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776243612581890)
-   [
    
    AI 零代码应用生成项目中，如何实现对生成后网站的实时预览？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776243935543297)
-   [
    
    AI 零代码应用生成项目中，实现对话历史功能时，前端如何配合后端游标分页机制进行数据请求？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776244216561665)
-   [
    
    AI 零代码应用生成项目中，实现可视化编辑功能时，前端如何捕获并传递 iframe 内的用户点击事件给父页面？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776244510162946)
-   [
    
    AI 零代码应用生成项目中，当用户开启可视化编辑并选中元素后，前端如何生成稳定且唯一的选择器？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776244833124353)
-   [
    
    AI 零代码应用生成项目中，哪些部分被抽象成了可复用的 Vue 组件？举例说明你开发一个组件时的主要思路。
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776245479047170)
-   [
    
    你是如何设计前端路由的？对于需要管理员权限的页面，在前端层面做了哪些访问控制？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776245881700353)
-   [
    
    AI 返回的 Markdown 内容包含代码块，前端是如何解析并实现代码高亮的？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776246179495938)
-   [
    
    从前端性能优化的角度看，你觉得这个项目还有哪些可以改进的地方？
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776246439542785)
-   [
    
    AI 零代码应用生成项目中，你如何实现了前后端项目的部署上线？请介绍完整流程
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776246695395329)
-   [
    
    AI 零代码应用生成项目中，从哪些方面进行了系统优化？请举例说明
    
    
    
    ](https://www.mianshiya.com/bank/1958777633583927297/question/1958776246997385218)


---


# 前端如何处理与后端的 SSE 流式通信，并实时展示 AI 的打字机效果？

前端主要通过浏览器内置的 `EventSource` API 来实现与后端的 SSE 流式通信和实时打字机效果。

实现细节：

1）建立连接：前端通过 `new EventSource(url, { withCredentials: true })` 创建一个实例，连接到后端的 SSE 接口。URL中会携带 `appId` 和用户消息等参数，`withCredentials: true` 确保请求会携带 Cookie 以供后端进行用户认证。

2）监听消息：通过为 `EventSource` 实例设置 `onmessage` 事件监听器来接收服务器推送的数据。后端为了防止空格丢失，会将每个数据块包装在一个JSON对象中（如 `{"d": "chunk"}`），前端在 `onmessage` 回调中解析这个JSON以获取真实的数据片段。

3）实现打字机效果：前端在组件内部维护一个字符串变量 `fullContent`，每当 `onmessage` 事件触发时，就将新接收到的数据块追加到 `fullContent` 变量的末尾。然后，将这个不断增长的 `fullContent` 赋值给Vue组件中用于渲染AI回复的响应式变量。通过这种方式，UI会随着数据的接收而持续更新，实现打字机效果。

4）处理流结束：后端在数据流完全结束后，会发送一个名为 `done` 的自定义事件。前端通过 `eventSource.addEventListener('done', ...)` 来监听此事件，一旦接收到，就调用 `eventSource.close()` 方法关闭连接，停止接收数据，并触发网站预览的更新。

5）错误处理：前端通过 `onerror` 事件监听器来处理网络中断等连接错误。我还专门监听一个自定义的 `business-error` 事件，用于处理后端在流建立前就抛出的业务异常，向用户展示准确的错误信息。


---


# AI 零代码应用生成项目中，如何实现对生成后网站的实时预览？

## 

12065\. AI 零代码应用生成项目中，如何实现对生成后网站的实时预览？ 

项目通过在前端页面内嵌 `iframe` 并结合后端静态文件服务的方式，实现对生成后网站的实时预览。

1.  在应用对话页面的右侧区域，放置一个 `iframe` 元素，作为承载生成后网站的容器。
2.  后端提供了一个专门的静态资源接口，该接口可以根据传入的路径，从服务器的特定文件目录中读取并返回对应的静态文件。后端在生成代码时，会根据应用的 `codeGenType` 和 `appId` 将文件保存在一个唯一的子目录下。
3.  当前端通过 SSE 接收完所有AI生成的代码片段后，后端会完成文件的保存。此时，前端会根据当前应用的 `appId` 和 `codeGenType` 构造一个指向后端静态资源服务的URL。对于Vue工程项目，URL会指向构建产物 `dist` 目录下的 `index.html`。
4.  最后，前端将这个构造好的 `previewUrl` 赋值给 `iframe` 的 `src` 属性。`iframe` 接收到新的 `src` 后，会向该URL发起请求，后端静态资源接口则返回 `index.html` 及其引用的资源，最终在 `iframe` 中渲染出完整的网站预览效果。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/OrFoDX5u_1752762717001-aae8ab1f-7965-43b5-8fa7-3f8041530c90_mianshiya.png)




---


# AI 零代码应用生成项目中，实现对话历史功能时，前端如何配合后端游标分页机制进行数据请求？

前端通过维护一个游标状态，并将其作为请求参数，来配合后端的游标分页机制，实现高效的对话历史加载。

1）前端在组件的状态中维护一个名为 `lastCreateTime` 的变量，它存储当前消息列表中最老一条消息的创建时间。这个变量就是前端的游标。

2）当用户进入对话页面时，前端会首次调用对话历史接口，此时不传递 `lastCreateTime` 参数。后端接收到没有游标的请求后，会查询并返回最新的一页数据。

3）前端接收到数据后，会将列表中最后一条消息的 `createTime` 赋值给 `lastCreateTime` 变量，为下一次加载做准备。

4）当用户触发加载更多历史消息时，前端会再次调用同一个接口，但这次会在请求参数中带上当前存储的 `lastCreateTime` 值。

5）后端根据传入的 `lastCreateTime` 参数，在数据库查询中加入条件，只拉取比该时间更早的数据，避免数据重复和偏移量查询的性能问题。

6）前端收到返回的旧消息列表后，会将这些消息通过 `unshift` 方法添加到现有消息数组的 最前面，以保证整个对话列表按时间顺序正确显示。


---


# AI 零代码应用生成项目中，实现可视化编辑功能时，前端如何捕获并传递 iframe 内的用户点击事件给父页面？

在可视化编辑功能中，前端利用动态脚本注入和 `postMessage` API 实现了跨窗口通信，捕获并传递 `iframe` 内的点击事件。

具体实现细节：

1）首先通过 Vite 的代理配置，保证主应用页面和 `iframe` 中加载的预览网站处于同源，这是动态注入脚本和通信的前提。

2）当用户点击进入编辑模式时，父页面会创建一个 JavaScript 脚本，并将其动态注入到 `iframe` 的 `document` 中。这个脚本是实现后续所有操作的核心。

3）被注入的脚本会在 `iframe` 内部的 `document` 上添加一个 `click` 事件监听器，并且是在捕获阶段进行监听。这样无论用户点击哪个具体元素，该事件都能被最外层的监听器捕获到。

4）当点击事件发生时，注入的脚本会阻止事件的默认行为和冒泡，然后收集被点击元素的相关信息，比如标签名 、ID、类名，以及一个通过遍历DOM树向上生成的唯一 CSS 选择器。

5）脚本将收集到的元素信息打包成一个对象，然后调用 `window.parent.postMessage(payload, '*')` 方法，这个方法将数据作为消息安全地发送给 `iframe` 的父窗口。

6）父页面会设置一个 `'message'` 事件的监听器。当接收到来自 `iframe` 特定类型的消息时，它会解析消息中的数据，并更新自己的状态，得知用户在 `iframe` 中选中了哪个元素。


---


# AI 零代码应用生成项目中，当用户开启可视化编辑并选中元素后，前端如何生成稳定且唯一的选择器？

## 

12068\. AI 零代码应用生成项目中，当用户开启可视化编辑并选中元素后，前端如何生成稳定且唯一的选择器？ 

前端通过在注入到 `iframe` 的脚本中实现一个名为 `generateSelector` 的函数，来为用户选中的元素生成一个稳定且唯一的 CSS 选择器，这个生成函数的生成逻辑是向上遍历 DOM 树，并逐步构建选择器路径。

具体步骤细节：

1.  函数从被点击的元素开始，向上遍历其父元素，直到 `document.body` 为止。
2.  在遍历的每一步，函数会首先检查当前元素是否拥有一个 ID。如果存在 ID，则认为该 ID 在页面中是唯一的，便将 `#id` 作为选择器的起点，并立即停止遍历。这是最稳定和高效的定位方式。
3.  组合标签名和类名：如果元素没有 ID，函数会使用其标签名和类名来构建选择器的一部分。
4.  使用 `:nth-child` 确保唯一性：为了区分没有唯一 ID 或类名的同级元素，函数会计算当前元素在其父元素的子节点中的位置，并附加一个 `:nth-child(n)` 伪类。这确保了即使有多个相同的标签和类的兄弟元素，也能被精确定位。
5.  路径拼接：在向上遍历的过程中，每一步生成的部分选择器都会被前置拼接到最终的选择器字符串上，中间用 `>` 连接符隔开，最终形成一个从顶层父元素到底层目标元素的完整、精确的路径。
6.  返回结果：这个最终生成的高度特定的选择器字符串，会被包含在通过 `postMessage` 发送给父页面的数据中，后续的 AI 修改指令可以使用这些数据。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/zHHJHKNl_1755763459688-649d6519-966a-4e4d-a75d-9e202dd596ab_mianshiya.png)

