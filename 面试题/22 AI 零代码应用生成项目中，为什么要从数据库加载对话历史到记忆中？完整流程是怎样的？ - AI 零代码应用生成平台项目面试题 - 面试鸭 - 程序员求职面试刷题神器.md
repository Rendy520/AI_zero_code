
# AI 零代码应用生成项目中，为什么要从数据库加载对话历史到记忆中？完整流程是怎样的？

“从数据库加载对话历史到记忆中” 是为了解决 Redis 中对话记忆可能因过期或服务重启而丢失的问题，保证 AI 即使在长时间未交互后，依然能够获取完整的历史上下文。

具体解释一下：Redis 中的数据通常会设置过期时间以控制内存占用。如果一个应用长时间没有交互，其在 Redis 中的对话记忆可能会被自动清除。但我在数据库的 `chat_history` 表中持久化了所有对话。因此，在开始新的对话前，从数据库加载最近的历史记录到 Redis 记忆中，可以实现记忆的恢复，保证对话的连续性。

完整流程如下：

1.  触发时机：在 `AiCodeGeneratorServiceFactory` 中创建新的 AI Service 实例时，会同步触发历史加载逻辑。
2.  查询数据库：`ChatHistoryService` 的 `loadChatHistoryToMemory` 方法会根据 `appId` 查询 `chat_history` 表中最近的 N 条对话记录（比如20条）。查询时会按创建时间降序排列。
3.  排除最新消息：查询时会跳过最新的一条用户消息，因为该消息在调用 AI 服务时会被自动添加到记忆中，排除它可以防止重复。
4.  清空旧记忆：在加载前，会先调用 `chatMemory.clear()` 清空 Redis 中可能存在的旧的、不完整的记忆，防止数据错乱。
5.  顺序加载：将从数据库查出的消息列表进行反转，确保是按时间正序，然后遍历列表，根据消息类型将其逐条添加到 `MessageWindowChatMemory` 实例中，这个过程会将历史对话写入 Redis。

这样，每次对话开始时，AI 的记忆都被预热到了最近的状态，从而能够进行连贯的、有上下文的对话。
