
# 介绍 AI 零代码应用生成项目的后端整体架构，有哪些核心模块，它们之间是如何交互的？

这个平台的核心业务是让用户通过自然语言描述需求，AI 自动生成一个完整的网站应用，用户可以自行可视化修改网站并在满意后部署网站。

为了支撑这个流程，我将后端设计为几个核心模块：

-   用户模块：负责用户的注册、登录、权限控制。
-   应用模块：负责应用的增删改查、精选、实时浏览、代码下载、应用封面图生成。
-   AI 代码生成模块：项目的技术核心，封装了和大模型的交互逻辑。基于 `LangChain4j` 框架实现，支持原生 HTML、多文件和 Vue 工程等多种生成模式。
-   对话与记忆模块：为了支持应用的迭代开发，我设计了对话历史的持久化存储，并利用 Redis 为每个应用实现了独立的、可持久化的 AI 对话记忆。
-   文件处理与构建模块：AI 生成的代码需要被解析和保存。我设计了代码解析器和文件保存器，并针对 Vue 工程引入了自动化的项目构建能力。
-   可视化编辑模块：为了让用户能更精确地修改应用，后端为 AI 提供了文件读、写、改、删等一系列工具，支持对已有代码的快速增量修改。
-   AI 工作流模块：为了提升生成网站的质量，我引入了 `LangGraph4j` 框架，将代码生成过程重构为一个标准化的 AI 工作流，包括图片素材搜集、提示词增强、代码生成、质量检查等多个自动化节点。
-   部署模块：用户可以对生成满意的网站一键部署。我采用 Nginx 作为 Web 服务器来托管静态资源，并为每个应用生成唯一的访问路径。
-   可观测性模块：为了确保平台的稳定运行，我集成了 `ARMS` 进行系统性能监控，并使用 `Prometheus` + `Grafana` 实现了对 AI 调用次数、Token 消耗等关键业务指标的自定义监控。

这些模块的交互流程是：用户通过 **用户模块** 登录后，通过 **应用模块** 创建一个应用，这会触发 **AI 智能路由** 选择生成模式。接着，用户在 **对话模块** 中与 AI 交互，**AI 代码生成模块** 或 **AI 工作流模块** 会被调用，生成的文件由 **文件处理模块** 保存。最后，用户通过 **部署模块** 发布应用，整个过程由 **可观测性模块** 监控。

架构图如下：

![](https://pic.code-nav.cn/mianshiya/question_picture/markdown/qw9ScxIt_1755778778522-58a2bbd4-da50-4802-97b0-f8cff9179293_mianshiya.png)


---


# MyBatis Flex 和 MyBatis Plus 的区别？为什么在项目中选择它？

MyBatis Flex 和 MyBatis Plus 都是对原生 MyBatis 框架的增强工具，能够简化数据库操作、提高开发效率。但它们在设计理念和功能侧重点上有所不同。

- 轻量化： MyBatis Flex 核心设计的一大优势是更轻量。除了 MyBatis 自身，它没有任何第三方依赖，这带来了更高的自主性、可控性和稳定性。相比之下，MyBatis Plus 整合的功能更多，依赖也相对复杂一些。

- 性能： MyBatis Flex 在架构上进行了优化，在 SQL 执行过程中没有任何 MyBatis 拦截器和 SQL 解析，官方宣称能带来指数级的性能提升。

- 功能灵活性： MyBatis Flex 的 QueryWrapper 非常灵活，一个核心亮点是它原生支持多表关联查询，这在处理复杂业务场景时非常有用。而 MyBatis Plus 在多表查询方面则需要依赖其他插件或手写 SQL 来实现。

项目选型原因：

在这个项目中，我们选择 MyBatis Flex 主要基于以下考虑：

1. 技术栈更新与学习： 为了丰富技术栈，体验和学习新的、有竞争力的技术框架。

2. 性能优势： 看重其无拦截器、无 SQL 解析带来的性能潜力。

下图是官方提供的与 MyBatis Plus 的功能对比：
![](https://pic.code-nav.cn/mianshiya/question_picture/markdown/kx0Ra3al_1755830827846-ed36f33c-3e4f-4930-b713-e12cb2085b2f_mianshiya.png)

---


# 什么是策略模式？AI 零代码应用生成项目中，你如何使用策略模式处理代码解析逻辑？

策略模式是一种行为设计模式，它定义了一系列算法，将每个算法都封装起来，并使它们可以相互替换。 这样做的核心优势是，算法的变化不会影响到使用算法的客户端代码，实现算法逻辑与客户端的解耦。

在我们的项目中，这个模式被用来优化 AI 生成代码后的解析逻辑。因为我们支持多种代码生成模式，每种模式 AI 返回的原始文本结构不同，因此需要不同的解析策略。

具体实现如下：

1）我们首先定义了一个统一的 `CodeParser<T>` 接口。 这个接口规范了所有代码解析器的行为，它包含一个核心的 `parseCode` 方法，负责接收 AI 生成的完整代码字符串并返回一个特定类型的结构化结果对象。泛型 `T` 可以让每种策略可以返回不同的结果类型。

2）实现具体策略：

-   `HtmlCodeParser`：实现了 `CodeParser<HtmlCodeResult>` 接口，专门负责从 AI 的回复中提取单个 HTML 代码块。
-   `MultiFileCodeParser`：实现了 `CodeParser<MultiFileCodeResult>` 接口，负责从 AI 的回复中分别提取 HTML、CSS 和 JavaScript 三个不同的代码块。

3）使用执行器进行调度：由于不同策略的返回值类型不同，直接使用传统的工厂模式来创建和调用会比较困难。所以我们引入了一个 `CodeParserExecutor`。这个执行器内部持有所有具体的策略实例，并提供一个统一的 `executeParser` 方法。该方法根据传入的 `CodeGenTypeEnum`，选择并执行对应的解析策略，对上层调用方屏蔽了内部的实现差异和复杂性。

这种执行器 + 策略模式的组合架构如下图所示：

![](https://pic.code-nav.cn/mianshiya/question_picture/markdown/gcG1r1RK_1755832760623-d8cce897-5b1b-4bc0-96f1-831a19138f6a_mianshiya.png)

这样我们的代码解析逻辑非常清晰、可维护性高。如果未来要支持新的代码生成模式，我们只需要新增一个对应的解析策略类，并在执行器中增加一个 case 分支即可，遵守对扩展开放，对修改关闭的设计原则。


---


# 什么是模板方法模式？AI 零代码应用生成项目中，你如何使用模板方法模式处理文件保存逻辑？

模板方法模式是一种行为设计模式，它在一个抽象父类中定义了一个操作的标准流程或骨架，并将一些具体的、可变的实现步骤延迟到子类中去完成。 这样，子类可以在不改变算法整体结构的情况下，重新定义该算法的某些特定步骤。

在我们的项目中，这个模式被用来优化代码文件的保存流程。 无论是生成单文件 HTML 应用还是多文件应用，其核心保存流程是相似的：**验证输入 -> 创建唯一目录 -> 保存文件**。但具体 保存文件 这一步的实现是不同的：HTML 模式只保存一个 `index.html`，而多文件模式需要分别保存 `index.html`、`style.css` 和 `script.js`。

1）定义抽象模板：我们创建了一个抽象类 `CodeFileSaverTemplate<T>`。它定义了一个 `final` 的 `saveCode` 方法，这就是模板方法。这个方法固定了文件保存的整体流程，保证所有子类的保存行为都遵循统一的规范。

2）实现具体子类：

-   `HtmlCodeFileSaverTemplate`：继承自抽象模板，实现了 `saveFiles` 方法，逻辑是在指定目录下写入一个 `index.html` 文件。 它还重写了 `validateInput` 方法，增加了对 HTML 代码非空的校验。
-   `MultiFileCodeFileSaverTemplate`：同样继承自抽象模板，但它的 `saveFiles` 方法会分别写入 `index.html`、`style.css` 和 `script.js` 三个文件。

3）通过执行器调用：与策略模式类似，我们使用 `CodeFileSaverExecutor` 来根据代码生成类型，选择并调用相应的模板子类来执行保存操作，对上层屏蔽具体实现的差异。

架构如下图所示：

![](https://pic.code-nav.cn/mianshiya/question_picture/markdown/mwowSu5c_1755832948165-40af3eca-3cb2-4d03-a6fd-8f107fb919ed_mianshiya.png)

它把文件保存流程中的不变部分和可变部分分离开来，代码结构清晰，复用性强。当需要支持新的文件保存逻辑时，只需创建一个新的子类并实现其特定步骤即可。


---


# 为什么基于 Selenium 实现浏览器自动化操作时，建议搭配 WebDriverManager 使用？什么是 WebDriver？

**WebDriver** 是 Selenium 的核心组件，它是一个标准化的接口，相当于程序代码与浏览器之间的桥梁。 我们的自动化脚本通过调用 WebDriver 的 API发出指令，WebDriver 再将这些标准指令翻译成特定浏览器（如 Chrome、Firefox）能够理解的原生命令，实现对浏览器的远程控制。

![](https://pic.code-nav.cn/mianshiya/question_picture/markdown/kYfeqUC8_1755833301976-d6c54794-0398-42f0-8cc3-a3aedabc7209_mianshiya.png)

之所以强烈建议搭配 **WebDriverManager** 使用，是因为它极大地简化了 WebDriver 的管理工作，解决了传统方式下的诸多痛点：

-   自动检测：自动检测本地安装的浏览器版本。
-   自动下载：根据浏览器版本，从官方源自动下载最匹配的 WebDriver。
-   自动配置：自动将下载好的 WebDriver 路径配置到系统属性中，让 Selenium 可以直接找到它。
-   缓存管理：会将下载的驱动程序缓存到本地，避免重复下载，提升效率。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/OKTfCfOg_1755833341091-f9b1ce3b-1c5a-4ce8-88e2-4a48e2cc90b8_mianshiya.png)

使用 WebDriverManager 可以让我们从繁琐的驱动管理中解脱出来，更专注于自动化业务逻辑的实现，同时保证了自动化脚本在不同环境、不同浏览器版本下的健壮性和可移植性。

![img](https://pic.code-nav.cn/mianshiya/question_picture/markdown/3GVHeOCh_1755833323330-b1dd50d7-0385-455b-8e99-298f0a8f13d0_mianshiya.png)


---


# AI 零代码应用生成项目中，你是如何实现集中式工具管理的？

在项目中，随着提供给 AI 的工具越来越多，如果分散管理，会导致代码混乱且难以维护。

因此，我们设计了一套集中式的工具管理机制，其核心是 `ToolManager` 类 + Spring 框架的依赖注入 + 设计模式。

整体架构如下：

![](https://pic.code-nav.cn/mianshiya/question_picture/markdown/D0CcS65H_1755833556997-4d832cb2-c719-4e3e-b4c4-61be35819871_mianshiya.png)

具体实现步骤：

1）定义工具基类：我们首先创建了一个抽象的 `BaseTool` 基类。 这个基类定义了所有工具都必须具备的通用接口和行为，例如 `getToolName()`和 `getDisplayName()`，以及生成不同阶段向用户展示信息的统一方法。

2）实现具体工具：项目中的每一个具体工具，如 `FileWriteTool`、`FileReadTool`、`FileModifyTool` 等，都继承自 `BaseTool` 基类，并被声明为 Spring 的 Bean。 这样，它们就可以被 Spring 容器自动扫描和管理。

3）创建工具管理器：这是集中管理的核心。

-   `ToolManager` 本身也是一个 Spring Bean。
-   它通过 `@Resource` 注解，注入了一个 `BaseTool` 类型的**数组**。这是关键一步，Spring 会自动将容器中所有继承了 `BaseTool` 的 Bean 实例收集起来，并注入到这个数组中。
-   在 `@PostConstruct` 初始化方法中，`ToolManager` 会遍历这个工具数组，将每个工具实例以其 `toolName` 为键，存入一个内部的 `Map` 中，方便后续通过名称快速查找。

4）统一使用：

-   `ToolManager` 提供了 `getTool(String toolName)` 方法，可以根据名称快速获取任何一个已注册的工具实例。
-   它还提供了 `getAllTools()` 方法，直接返回包含所有工具实例的数组，这个方法专门用于为 LangChain4j 的 AI Service 统一注册所有可用工具。

通过这种方式，我们实现了工具的自动注册和集中管理。未来如果需要新增一个工具，我们只需要创建一个新的类继承 `BaseTool` 并加上 `@Component` 注解即可，无需修改任何现有管理和注册逻辑的代码。


---


# 项目支持多种 AI 代码生成模式，从架构层面是如何设计和隔离不同模式的生成逻辑的？

为了支持原生 HTML、多文件和 Vue 工程这三种不同的代码生成模式，我在架构设计上采用了门面模式 + 策略模式 + 工厂模式相结合的方式，实现了逻辑的清晰隔离和灵活扩展。

核心设计如下：

1）我创建了一个 `AiCodeGeneratorFacade` 门面类，它对外提供一个统一的 `generateAndSaveCodeStream` 方法。这个方法接收用户消息和代码生成类型作为参数，屏蔽了内部不同生成模式的实现细节。

2）在 `AiCodeGeneratorService` 接口中，我为每种生成模式定义了不同的方法，比如 `generateHtmlCodeStream` 和 `generateVueProjectCodeStream`。每种方法都通过 `@SystemMessage` 注解关联一个独立的系统提示词文件，确保 AI 在执行任务时遵循该模式特定的规则和约束。

3）在 `AiCodeGeneratorServiceFactory` 中，我实现了一个工厂方法 `getAiCodeGeneratorService`，它会根据传入的 `CodeGenTypeEnum` 来动态构建和配置 `AiCodeGeneratorService` 实例。

-   对于 Vue工程模式，它会配置使用能力更强的推理模型，并注入文件写入等一系列工具，因为这种模式依赖于工具调用来生成项目文件结构。
-   对于原生 HTML 和多文件模式，它会配置使用成本更低的对话模型，并且不注入任何工具，因为这两种模式是直接通过解析 AI 输出的 Markdown 代码块来保存文件的。

4）由于不同模式下 AI 的流式输出格式不同，我设计了 `StreamHandlerExecutor` 执行器，它会根据生成类型选择对应的流处理器来解析和处理 AI 的实时响应，实现了处理逻辑的隔离。

通过这种方式，每种生成模式的核心逻辑都被封装在各自的提示词、AI Service 配置和流处理器中，当未来需要支持新的生成模式时，我只需要新增相应的枚举、提示词文件，并在工厂类和执行器中增加一个分支即可，无需改动现有逻辑。

![](https://pic.code-nav.cn/mianshiya/question_picture/markdown/7UOKm56D_202508221358362_mianshiya.png)


---


# 如何为不同的 AI 代码生成模式设计和优化系统提示词？有哪些技巧？

1.给ai定义角色，让ai扮演一个专业的前端开发，避免ai基于自我认知的角色随意发挥 2.定义生成文件的规范，严格要求不去引入不必要的第三方的依赖和组件库，避免ai的不确定性影响项目生成的稳定性 3.编写生成文件的案例，引导ai的输出方向 4.限制最大输出的token，避免陷入死循环无限生成，并且告


---


# LangChain4j 在项目中有什么作用？你是如何将 AI 大模型能力集成到业务代码中的？

LangChain4j 在项目中是核心的 AI 开发框架，它的主要作用是简化和标准化与大模型交互的过程。它通过一套声明式的 API ，让我可以不用关心底层 HTTP 请求和复杂的 JSON 处理，更专注于业务逻辑的实现。

我主要是通过 AI Service 这种模式将大模型能力集成到业务代码中的，这个过程可以分为几个步骤：

1）定义服务接口：我创建了一个 `AiCodeGeneratorService` 接口，并在其中定义了与业务相关的方法，比如 `generateHtmlCodeStream` 和 `generateVueProjectCodeStream`。

2）使用注解驱动：在接口方法上，我使用了 LangChain4j 提供的注解来配置AI的行为。

-   `@SystemMessage`：用于关联一个系统提示词文件，设定AI的角色和任务约束。
-   `@UserMessage`：用于标记哪个方法参数是用户的输入。
-   `@MemoryId`：用于为不同的对话分配独立的记忆空间，这在实现按应用隔离对话记忆时非常关键。

3）创建服务实例：我编写了一个 `AiCodeGeneratorServiceFactory` 工厂类，使用 `AiServices.builder()` 来构建 `AiCodeGeneratorService` 接口的动态代理实现。在这个构建过程中，我可以注入配置好的 `ChatModel` 或 `StreamingChatModel`，还可以注册工具、配置对话记忆和护轨等。

4）业务层调用：最后，在我的业务逻辑中，我可以直接注入并调用 `AiCodeGeneratorService` 接口的方法，就像调用一个普通的 Java 方法一样，LangChain4j 框架会自动处理与大模型的所有通信细节。

除了基本的对话功能，我还利用了 LangChain4j 的其他核心特性，比如通过结构化输出将 AI 的 JSON 响应自动映射为 Java 对象，通过工具调用让 AI 能够使用我提供的 `FileWriteTool` 等工具来生成复杂的 Vue 工程项目。


---


# 如何实现将 AI 大模型的输出稳定地转换为结构化对象？

为了让程序能方便地处理 AI 生成的代码和描述，我利用了 LangChain4j 的结构化输出功能，将 AI 返回的自由文本自动转换为预定义的 Java 对象，比如 `HtmlCodeResult` 和 `MultiFileCodeResult`。

实现方式很简单，只需要将 AI Service 接口方法的返回值类型从 `String` 改为对应的 Java 类即可，LangChain4j 框架会自动在发送给大模型的提示词中追加指令，要求其以 JSON 格式返回数据。

但在实践过程中，我发现 AI 并不能 100% 稳定地返回符合预期的 JSON，主要遇到了 AI 返回非 JSON 格式或 JSON 结构错误的问题，导致程序解析失败。

为了解决这个问题，我采取了以下几种优化措施：

1.  设置 `max_tokens`：在模型配置中，我增大了 `max-tokens` 的值，比如设置为 8192，以防止 AI 生成的 JSON 内容因为超出长度限制而被截断，从而导致 JSON 格式不完整。
2.  开启模型的 JSON 模式：我查阅了 DeepSeek 模型的官方文档，发现它支持通过 `response-format` 参数强制开启 JSON 输出模式。于是我在`application.yml`配置文件中添加了 `response-format: json_object`，这极大地提高了输出的稳定性。
3.  为字段添加详细描述：为了让 AI 更好地理解期望的JSON结构，我使用了 LangChain4j 提供的 `@Description` 注解，为结果类及其每个字段都添加了清晰的中文描述，比如 `@Description("HTML代码")`。这些描述会被框架自动转换并附加到提示词中，为 AI 提供了更明确的指引。
4.  在提示词中补充 JSON 格式输出的要求

通过这些手段，结构化输出的成功率得到了显著提升。对于偶尔出现的失败情况，LangChain4j 框架自带的默认重试机制也能够处理大部分问题。
