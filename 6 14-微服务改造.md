---
source: https://www.codefather.cn/course/1948291549923344386/section/1960544845213282305
---

# 14 - 微服务改造 - 【大厂必备】LangChain4j +

## 本节重点

本节我们将为 AI 零代码应用生成平台进⁠行微服务架构改造，将原有的⁠单体应用拆分为多个独立的微服务，提升系统的可扩展性、可维护性和部署灵活性。

微服务架构是现代大型应用的主⁠流架构模式，掌握微⁠服务改造技能对提升架构设计能力也是很必要的。

本节主要内容包括：

-   微服务基本概念
-   微服务架构设计
-   微服务拆分实战
-   Nacos + Dubbo 服务间调用
-   Higress 微服务网关

注意，本节内容可独立于本项目学习，⁠鱼皮讲的是通用的单体项⁠目改造为微服务的套路和技巧，学会之后去改造任何项目应该都会比较轻松~

## 一、什么是微服务？

微服务是一种软件架构风格，它将应用程⁠序构建为一组小型、独立的⁠服务，每个服务都围绕特定的业务功能构建，并通过明确定义的 API 进行通信。

为了更好地理解微服务架构的作⁠用，先给大家举个例⁠子，看看单体架构和微服务架构的对比。

单体架构：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Gg6W63vzAhRptGti.webp)

微服务架构：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/52nuKKRiq62qzqs5.webp)

从图中可以看出，单体架构将所有功能模块集⁠中在一个应用中，而微服务架⁠构将不同的业务功能拆分为独立的服务，每个服务都有自己的数据存储和业务逻辑。

### 微服务有哪些作用？

1）独立部署与运行：每个微服⁠务都可以独立开发、⁠测试、部署和扩展，彼此之间互不影响，大大降低了系统的耦合度。

举个例子，当我们需要修改用户⁠管理功能时，只需要⁠重新部署用户服务，其他服务完全不受影响，可以正常运行。

2）按业务功能划分：微服务的拆分遵循业务边界，每个服务⁠专注于特定的业务领域，做到高内聚、低⁠耦合。比如用户服务专门负责用户注册、登录、权限管理等功能，AI 服务则专注于代码生成、模型调用等核心能力。

3）技术选型灵活：不同的微服务可以根据自身特点选择最合适的技⁠术栈，不再受限于统一的技术架构。用户服务⁠可以用 MySQL 存储用户信息，应用服务可以用 Redis 缓存数据，截图服务可以用对象存储保存图片，各取所需。

4）弹性扩展：可以根据业务负载情况，针对性地扩展高压力⁠服务，实现资源的精准利用。比如 AI⁠ 代码生成请求量激增时，我们只需要扩展 AI 服务的实例数量，而不用扩展整个应用，既节省成本又提升效率。

5）故障隔离：通过合理的容错设计（熔断、⁠重试、超时等机制），即使某⁠个服务出现故障，也不会影响其他服务的正常运行，大大提升了系统的整体可用性。

### 微服务的挑战

注意，微服务架构不是银弹，不⁠是什么时候都适用的⁠，它也会带来一些问题：

1）分布式复杂性：原本简单的本地方⁠法调用变成了跨网络的服⁠务调用，需要处理网络延迟、服务发现、数据一致性等分布式系统特有的问题。

2）运维复杂度提升：从管理一个应用变⁠成管理多个服务，监控、日⁠志收集、部署发布等运维工作的复杂度成倍增长，需要更完善的工具和流程支撑。

3）服务治理挑战：需要解决服务注册发⁠现、负载均衡、配置管理、⁠链路追踪等一系列问题，通常需要引入Nacos、网关等额外的基础设施组件。

4）数据一致性难题：在分布式环境下，⁠如何保证跨服务的数据一致⁠性是一个技术难点，往往需要采用最终一致性方案，增加了业务逻辑的复杂性。

而且很多问题的解决都要从单体考虑到分布式场景，比⁠如单机锁 => 分布式锁、单机限⁠流 => 分布式限流、单机定时任务 => 分布式定时任务，会增加很多的开发成本和复杂任务。

因此，在进行微服务改造时，需⁠要充分权衡利弊，选⁠择合适的拆分策略。

💡 注意：DDD 领域驱动设计和微服务架构完⁠全是两码事，DDD 是一种软件⁠设计方法论，而微服务是一种架构风格。DDD 可以指导微服务的拆分，但不等同于微服务本身。

想学习实战 DDD 架构的朋友可以看 [编程导航的智能协同云图库项目](https://www.codefather.cn/course/1864210260732116994) 第 14 期。

## 二、微服务架构设计方案

在开始微服务改造之前，我们需要思考几个关键问题：

1.  **设计上：怎么划分服务？** 按照什么原则将单体应用拆分为多个微服务？
2.  **实现上：用什么技术？** 选择什么技术栈来支撑微服务架构？
3.  **治理上：如何管理服务？** 如何实现服务注册发现、配置管理、监控等？

接下来我们逐一分析这些问题。

### 服务划分

微服务拆分是整个改造过程中最⁠关键的一步，拆分得⁠好不好直接决定了后续开发和维护的复杂度。

#### 拆分原则

在进行微服务拆分时，我们遵循以下原则：

1.  业务领域驱动：按照业务功能进行拆分，确保每个服务都有明确的业务边界。比如用户管理、应用管理、AI 代码生成等，每个领域的业务逻辑相对独立。
2.  数据一致性：相关性强的数据保持在同一服务中，减少跨服务的数据依赖。比如用户信息和用户权限放在同一个服务中，避免跨服务查询。
3.  团队组织：考虑团队规模和技能分工，确保每个服务都有专门的团队负责。一般来说，一个微服务团队的规模在2-8人之间比较合适。
4.  性能考虑：将重计算模块独立出来，便于单独优化和扩展。比如AI代码生成和网页截图都是计算密集型任务，独立部署便于资源优化。
5.  扩展性需求：根据不同模块的扩展需求进行拆分。访问频率高的模块可以独立扩展，不影响其他服务。

注意！拆分微服务时一定要灵活，不能拆的不要硬拆！⁠如果两个功能模块耦合度很高，频繁⁠需要相互调用，那么强行拆分反而会增加系统复杂度。等会儿鱼皮也会在这个项目中给大家演示这一点。

#### 基础服务划分

基于以上原则，我们可以将系统划分为以下模块：

**通用模块**

这些模块不是独立的服务，而是被其他服务依赖的公共组件：

-   yu-ai-code-common：包含所有服务公用的代码，如异常处理、工具类、常量定义等，为其他服务提供基础设施支持。
-   yu-ai-code-model：统一的数据模型定义，包含实体类、DTO、VO、枚举类等，确保各服务间数据格式的一致性。
-   yu-ai-code-client：定义需要内部调用的服务接口，作为服务间通信的契约，实现服务间的松耦合。

**业务服务**

这些是真正的微服务，（原则上⁠来说）每个服务都有⁠独立的进程和端口：

-   用户服务：作为整个系统的基础，统一管理用户状态和权限。负责用户注册、登录、注销、权限验证等核心功能。**由于几乎所有业务都需要用户信息，所以用户服务是其他服务的基础依赖。**
-   应用服务：业务核心服务，负责应用的完整生命周期管理。包括应用创建、编辑、删除、对话历史、代码保存、项目下载等功能，集成了文件操作、缓存管理、限流控制等能力。
-   AI 服务：专门处理代码生成相关功能，集成 LangChain4j 支持流式响应。包含 AI 模型调用、代码生成功能。
-   截图服务：独立的 IO 密集型服务，使用 Selenium WebDriver 进行网页截图。由于截图操作比较消耗 CPU 和内存资源，独立部署便于单独优化和扩展。

当然，这只是初步的划分，也是⁠比较理想的情况，实⁠际上真的能这么操作么？还得看看各个服务间的依赖关系。

#### 服务间依赖关系

在微服务架构中，服务间不能像⁠之前那样通过本地方⁠法调用，需要通过网络进行远程调用。我们的服务间依赖关系如下：

-   应用服务 → 用户服务：应用服务需要调用用户服务获取用户信息、进行权限验证。比如创建应用时需要验证用户身份，查询应用列表时需要获取创建者信息。
-   应用服务 → 截图服务：应用服务在生成代码后，需要调用截图服务生成应用的预览图，方便用户查看效果。
-   应用服务 ←→ AI 服务：这是一个双向依赖关系。应用服务需要调用 AI 服务进行代码生成，而 AI 服务在生成完成后需要调用应用服务保存聊天历史。

#### 服务划分结果

通过梳理服务间依赖关系，我们发现应用服务和 AI 服务是强绑定的关系，**因此 AI 服务不能作为完全独立的服务占用独立端口，而是作为 SDK 模块引入到应用服务中**。

当然，还有其他的原因：

1.  技术限制：Dubbo 的序列化机制不支持 Reactor 的 Flux 类型，无法通过 Dubbo 调用返回流式响应。
2.  性能考虑：AI 代码生成是流式响应，如果通过网络传输会增加延迟和复杂度。

另外，工作流和可观测性模块作⁠为本项目中可独立学⁠习的非核心业务，暂不迁移。

\*\*最后，我们需要整理出一个微服务划分表。\*\*包括各个服务的职责、端口分配、路由规划和依赖关系，便于后续的开发实现。



|服务名称|端口和路由前缀|主要功能|依赖服务|
|---|---|---|---|
|通用模块||
|yu-ai-code-common|\-|注解、异常处理、工具类、常量、公共响应类|\-⁠|
|yu-ai-code-model|\-|实体类、DTO、⁠VO、枚举类、AI 模型类|common|
|yu-ai-code-client|\-|服务接口定义、内部调用契约|common、model|
|业务服务||
|yu-ai-code-user|8124 端口，/api/user/\*\*|用户管理、权限认证、用户信息维护|Redis、MySQL|
|yu-ai-code-app|8125 端口，/api/app/**/api/chatHistory/**|应用管理、聊天历史、项目下载、代码解析保存|Redis、MySQL、用户服务、截图服务|
|yu-ai-code-ai ⁠|\-|AI代⁠码生成、模型管理 |AI 大模型|
|yu-ai-code-screenshot|8127 端口，/api/screenshot/\*\*|网页截图、图片处理、对象存储|腾讯云 COS|

### 微服务技术选型

微服务架构需要解决服务拆分、服务间通信、服务发现、统一网关等核心问题。对应这些⁠需求，我们需要选择合适的技术栈，包括开发框架、注册中⁠心、服务调用、微服务网关。本项目将使用 Spring Cloud Alibaba、Nacos、Dubbo、Higress 网关这套完整的解决方案。

#### 微服务开发框架

微服务开发框架是构建微服务应用的基础，它提供了服务注册⁠发现、配置管理、负载均衡、熔断降级等⁠微服务治理能力的统一抽象。没有框架的话，开发者需要自己处理这些复杂的分布式问题，开发效率会大大降低。

目前主流的 Java 微服务开发框架包括：

-   Spring Cloud：基于 Spring Boot 的微服务框架，生态完善，社区活跃
-   Spring Cloud Alibaba：阿里基于 Spring Cloud 的扩展，集成了阿里云的微服务组件
-   Dubbo：阿里开源的高性能 RPC 框架，专注于服务调用

本项目选择 [Spring Cloud Alibaba](https://sca.aliyun.com/docs/2023/overview/what-is-sca/) 作为微服务开发框架，它是个全家桶，包含了开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。

核心组件包括：

-   服务发现与配置管理：集成了 Nacos 作为服务注册与发现、分布式配置管理的解决方案。
-   分布式事务：提供了 Seata 分布式事务解决方案，保证跨服务的数据一致性。
-   限流降级：集成了 Sentinel 流量控制组件，提供流量控制、熔断降级、系统负载保护等多个维度来保障服务之间的稳定性。
-   消息驱动：提供了对 RocketMQ 的支持，实现消息驱动的微服务架构。
-   分布式调度：集成了 SchedulerX 任务调度平台，提供分布式任务调度能力。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/zT25Wi4HhMmKyCj6.webp)

Spring Cloud Alibaba 的优势在于它完全兼容 Spring Cloud⁠ 标准，同时提供了阿里在分布式系统方面多年的技术积累和最佳⁠实践。对于咱们国内开发者，Spring Cloud Alibaba 还提供了更好的中文文档和社区支持，个人也会更推荐使用它而不是 Spring Cloud。

#### 注册中心

注册中心是微服务架构的核心组件，它解决了服务发现问题。

什么是服务发现呢？

在微服务环境中，服务实例会动态启动和停止，IP 地址和端口也可能经⁠常变化，服务消费者需要知道服务提供者的准确地⁠址才能发起调用。注册中心就像一个电话簿，服务启动时向注册中心报告自己的地址信息，服务调用时从注册中心查询目标服务的地址。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/bBqa00rfFuYomTnK.webp)

本项目选择和 Spring ⁠Cloud Ali⁠baba 兼容的 Nacos 作为注册中心。

[Nacos](https://nacos.io/)（Naming and Configuration Service）由阿里开源，是易于构建云原生应用的动态服务发现、配置管理和服务管理平台。它集成了服务注册与发现、配置中心、服务元数据管理等功能，是构建微服务架构的重要基础设施。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/TxdXdIsXbw5AehYC.webp)

除了 Nacos，其他注册中心比如 Eurek⁠a 适合 Spring Clo⁠ud 生态、Consul 提供了丰富的服务治理功能、Zookeeper 则适合高可用场景。

💡 [编程导航的智能面试刷题项目](https://www.codefather.cn/course/1826803928691945473) 中带大家实战过基于 Nacos 的动态配置管理能力，感兴趣的同学建议学习。

#### 微服务调用

微服务调用是指不同服务之间的通信方式。在单体应用⁠中，不同模块之间通过本地方法调用⁠进行交互，而在微服务架构中，服务部署在不同的进程甚至不同的机器上，需要通过网络进行远程调用。

常见的微服务调用技术包括：

-   HTTP/REST：基于 HTTP 协议的 RESTful API 调用，简单易用，跨语言支持好
-   RPC：远程过程调用，如 Dubbo、gRPC，性能更高，但通常需要相同的技术栈
-   消息队列：如 RocketMQ、Kafka，支持异步调用，适合解耦场景

HTTP 和 RPC 之间有什么区别呢？

简单来说，RPC 调用更像是本地方法调用，性能更高；而 HTTP 调用更加通用和标准化，跨语言支持更好。详情可以参考这道面试题：[RPC 和 HTTP 的区别](https://www.mianshiya.com/question/1799803242210992130)。

一个简易的 RPC 框架架构图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/vAcMNnhnXdJd5b5W.webp)

本项目选择 Dubbo 作为主要的服务调用方式。[Apache Dubbo](https://cn.dubbo.apache.org/) 是阿里开源的高性能 RPC 框架，提供了面向接口的远程方法调用、容错和负载均衡等能力，以及服务自动注册和发现。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/NX1PcAbsQlCfYw2D.webp)

💡 [编程导航的手写 RPC 框架项目](https://www.codefather.cn/course/1768543954720022530) 中参考 Dubbo 实现了自己的 RPC 框架，学习后会对 Dubbo 和 RPC 有更深的理解。

#### 微服务网关

微服务网关是微服务架构的统一入口，它解决了客户端如何访问多个微服务的问题。没有网关的话，客⁠户端需要直接调用各个微服务（输入不同的访问地址），这会导致客⁠户端与服务的强耦合，并且难以统一处理认证、限流、监控等横切关注点。网关就像一个保安（强行押韵，其实应该理解为门卫），统一处理外部请求，然后转发到内部的具体服务。

常见的微服务网关技术包括：

-   Spring Cloud Gateway：Spring 官方出品，和 Spring Cloud 生态集成度高
-   Higress：阿里巴巴开源的云原生 API 网关，基于 Envoy，性能优异
-   Kong：基于 Nginx 的开源网关，插件丰富
-   Zuul：Netflix 开源，较为成熟但性能一般

本项目选择 [Higress](https://higress.cn/) 作为微服务网关。Higress 是基于阿里内部多年 Envoy Gateway 实践的 **云原生 + AI 原生** API 网关，采用 C++ 实现，相比传统的 Java 网关具有更高的性能和更低的内存占用，而且能够和 Nacos 和 Dubbo 轻松集成。

什么是 AI 原生呢？可以看看 [官方对 AI 网关的介绍](https://higress.cn/docs/latest/overview/what-is-higress/)，简单来说，Higress 支持多种 AI 协议，提供 AI 可观测性、AI 代理缓存、AI 令牌限流、AI 大模型对接等能力。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/RXs3A7ITojlxqi12.webp)

下面是 Higress 与 ⁠Spring Cl⁠oud Gateway 的详细对比：



|对比项|Spring Cloud Gateway|Higress|
|---|---|---|
|性能|中等 (基于 Spring WebFlux)|高 (基于 Envoy C++)|
|内存占用|较高 (JVM)|较低 (C++)|
|配置方式|代码 + 配置文件|控制台 + 配置文件|
|插件生⁠态|Spring 生态|Envoy ⁠+ 自定义插件|
|可观测性|依赖 Spring Actuator|内置丰富的监控指标|
|云原生|支持|原生云原生设计|
|学习成本|低 (熟悉 Spring)|中等|
|AI 支持|需要自定义开⁠发|原生 AI⁠ 功能支持|

不过如何你需要在网关中写一些业务逻辑，Higr⁠ess 可能就不适合了，而 S⁠pring Cloud Gateway 是可以在代码中引入并且自定义 Java 业务逻辑的。

💡 [编程导航的 API 开放平台项目](https://www.codefather.cn/course/1790979723916521474) 和 [OJ 判题系统项目](https://www.codefather.cn/course/1790980707917017089) 都有关于 Spring Cloud Gateway 的实战。

### 微服务部署架构图

可以通过下面这个完整的部署架⁠构图，更直观地理解⁠我们的微服务架构设计：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/XMNglFDkM6kaTZjV.webp)

下面，我们来进行微服务拆分实战。

## 三、微服务拆分实战

### 创建项目结构

首先，我们需要创建微服务项目的整体结构。在原有项目的根目录下，我们创建一个新的微服务父项目 `yu-ai-code-mother-microservice`。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/vpIlG5cVMBdgJQlo.webp)

然后依次创建各个子模块：

```plain
yu-ai-code-mother-microservice/
├── pom.xml                          # 父项目 POM
├── yu-ai-code-common/              # 公共模块
├── yu-ai-code-model/               # 实体模型模块
├── yu-ai-code-client/              # 服务接口模块
├── yu-ai-code-user/                # 用户服务
├── yu-ai-code-app/                 # 应用服务
├── yu-ai-code-ai/                  # AI 代码生成
└── yu-ai-code-screenshot/          # 网页截图服务
```

![](https://pic.code-nav.cn/course_picture/1608440217629360130/bLxQlH3FSALCOCho.webp)

#### 明确依赖版本

注意，微服务开发中，由于涉及⁠的依赖较多，一定要⁠注意各个依赖版本的兼容性！

根据 [Spring Cloud Alibaba 的版本说明](https://sca.aliyun.com/docs/2023/overview/version-explain)，我们选择以下版本进行开发：



|技术组件|推荐版本|
|---|---|
|Java|21|
|Spring Boot|3.5.3|
|Spring Cloud（其实项目中用不到）|2023.0.1|
|Spring Cloud Alibaba|2023.0.1.0|
|Nacos Server|2.3.2|
|Dubbo|3.3.0|
|Higress|2.1.6|

**请严格遵循鱼皮的版本号！否则出任何问题可能都不好解决，浪费时间。**

#### 父项目 POM 配置

父项目的 POM 文件是整个⁠微服务项目的核心配⁠置文件，它定义了全局依赖版本号、引入全局依赖、配置打包插件等：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.yupi</groupId>
    <artifactId>yu-ai-code-mother-microservice</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <modules>
        <module>yu-ai-code-common</module>
        <module>yu-ai-code-model</module>
        <module>yu-ai-code-client</module>
        <module>yu-ai-code-user</module>
        <module>yu-ai-code-app</module>
        <module>yu-ai-code-ai</module>
        <module>yu-ai-code-screenshot</module>
    </modules>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <spring-boot.version>3.5.3</spring-boot.version>
        <spring-cloud.version>2023.0.1</spring-cloud.version>
        <spring-cloud-alibaba.version>2023.0.1.0</spring-cloud-alibaba.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
            <version>4.4.0</version>
        </dependency>
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>5.8.38</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.38</version>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.14.0</version>
                <configuration>
                    <parameters>true</parameters>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

这里需要注意一个重要的配置：必须配置 Maven 编译插件，并且设置编译时保留参数名信息（`-parameters` 标志），否则 Spring 无法通过反射获取请求参数名，会导致有些 GET 请求参数失效。

比如这个接口：

```java
@GetMapping("/get")
@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
public BaseResponse<User> getUserById(long id) {
    ThrowUtils.throwIf(id <= 0, ErrorCode.PARAMS_ERROR);
    User user = userService.getById(id);
    ThrowUtils.throwIf(user == null, ErrorCode.NOT_FOUND_ERROR);
    return ResultUtils.success(user);
}
```

如果没有正确配置编译插件，接⁠口文档就无法识别参⁠数名称，影响开发调试。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/yVLiAVw4QgPFCJid.webp)

### 通用模块构建

#### yu-ai-code-common 公共模块

公共模块包含所有模块公用的代⁠码，一般不包含业务⁠逻辑、不使用复杂的依赖。

这个模块的依赖配置如下：

```xml
<dependencies>
    <!-- 腾讯云 COS 对象存储 -->
    <dependency>
        <groupId>com.qcloud</groupId>
        <artifactId>cos_api</artifactId>
        <version>5.6.227</version>
    </dependency>
    <!-- MyBatis Flex 代码生成 -->
    <dependency>
        <groupId>com.mybatis-flex</groupId>
        <artifactId>mybatis-flex-codegen</artifactId>
        <version>1.11.0</version>
    </dependency>
    <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
    </dependency>
</dependencies>
```

接下来进行代码迁移，也就是把代码从原单体项目复制到新微服务项目的对应位置。**这里我们要确保迁移的包路径和之前完全一致，减少代码修改量。**

迁移内容：

-   common/ 公共请求响应类（BaseResponse、ResultUtils等）
-   constant/ 常量
-   exception/ 异常处理
-   generator/ 代码生成器
-   utils/ 工具类（除 WebScreenshotUtils 外）
-   config/ 配置类（JsonConfig、CorsConfig、CosClientConfig）
-   manager/ 通用能力（CosManager）
-   annotation/ 注解（AuthCheck）

注意事项：

-   ratelimit/ 限流模块涉及到引用 UserService，有一定的业务特性，因此不放到 common 中（可以单独定义成模块）
-   constant/ 常量也可以选择拆分到对应的业务模块中，比如 UserConstant 放到用户模块、AppConstant 放到应用模块

还有需要注意的是，引入 CosManager 后⁠，必须要填写 COS 配置才能启⁠动项目，但有些模块是不需要 CosManager 的。因此我们添加条件注解，没配置就不加载：

```java
@Configuration
@ConfigurationProperties(prefix = "cos.client")
@ConditionalOnProperty(
        prefix = "cos.client",
        name = {"host", "secretId", "secretKey", "region", "bucket"}
)
@Data
public class CosClientConfig {
}
```

```java
@Component
@ConditionalOnBean(COSClient.class)
@Slf4j
public class CosManager {
}
```

这样确保了只有在配置了 CO⁠S 相关参数时才会⁠加载相关的 Bean，避免了启动时的配置错误。

#### yu-ai-code-model 实体模型模块

实体模型模块的依赖配置很简单，只需要依赖公共模块：

```xml
<dependencies>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

然后迁移整个 model 包：

-   model/entity/ 实体类（User、App、ChatHistory）
-   model/dto/ 数据传输对象
-   model/vo/ 视图对象
-   model/enums/ 枚举类

由于这个模块依赖其他模块，需⁠要通过父项目进行统⁠一构建，这样可以确保依赖关系正确、版本一致、构建顺序合理。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/cnIYa7ZH0R22xINF.webp)

#### yu-ai-code-client 服务接口模块

这个模块定义了需要被其他服务内部调用的接口。

这里鱼皮沿用了基于 Feign 实⁠现的命名，client⁠ 的含义是可以和实际服务交互的客户端，你也可以重命名为 api 模块。

依赖配置如下：

```xml
<dependencies>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

为了和对外提供的接口区分，这个模块内的接口统一取名为 innerService，放到 `innerservice` 包下。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/SEu0s2oDOWa4cBv1.webp)

InnerUserServi⁠ce 定义了用户相⁠关的内部接口：

```java
User getLoginUser(HttpServletRequest request);

List<User> listByIds(Collection<? extends Serializable> ids);

User getById(Serializable id);

UserVO getUserVO(User user);
```

InnerScreensho⁠tService ⁠定义了截图相关的内部接口：

```java
String generateAndUploadScreenshot(String webUrl);
```

其中，用户服务的 `getLoginUser` 方法比较特殊，由于 HttpServletRequest 对象不好在网络中传递，因此采用静态方法，避免跨服务调用：

```java
public interface InnerUserService {

    List<User> listByIds(Collection<? extends Serializable> ids);

    User getById(Serializable id);

    UserVO getUserVO(User user);

    // 静态方法，避免跨服务调用
    static User getLoginUser(HttpServletRequest request) {
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User currentUser = (User) userObj;
        if (currentUser == null || currentUser.getId() == null) {
            throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);
        }
        return currentUser;
    }
}
```

注意，不能使用默认方法，否则⁠ Dubbo 会尝⁠试序列化，导致报错：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/JnA3f3J02GhJ1iRB.webp)

### 业务服务构建

#### yu-ai-code-user 用户服务

修改用户服务的依赖配置，包括⁠ Session ⁠管理、数据访问等功能：

```xml
<dependencies>
    <!-- Spring Session + Redis -->
    <dependency>
        <groupId>org.springframework.session</groupId>
        <artifactId>spring-session-data-redis</artifactId>
    </dependency>
    <!-- 必须引入，才能共享 Session -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
      <exclusions>
        <exclusion>
          <artifactId>lettuce-core</artifactId>
          <groupId>io.lettuce</groupId>
        </exclusion>
      </exclusions>
    </dependency>
    <dependency>
      <groupId>redis.clients</groupId>
      <artifactId>jedis</artifactId>
    </dependency>
    <!-- 数据访问 -->
    <dependency>
        <groupId>com.mybatis-flex</groupId>
        <artifactId>mybatis-flex-spring-boot3-starter</artifactId>
        <version>1.11.0</version>
    </dependency>
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

💡 注意，我们必须引入 `spring-boot-starter-data-redis` 依赖，才能在微服务环境中共享 Session，并且这里鱼皮采用了 jedis 连接池替代默认的 lettuce 连接池，让连接池管理更稳定。

编写配置文件 `application.yml`，包含了应用基本信息、Session 配置、数据库配置、Redis 配置等：

```yaml
spring:
  application:
    name: yu-ai-code-user
  # session
  session:
    store-type: redis
    # 30 days expire
    timeout: 2592000
  # mysql
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/yu_ai_code_mother
    username: root
    password: 123456
  # redis
  data:
    redis:
      host: localhost
      port: 6379
      database: 0
      password:
  profiles:
    active: local
server:
  port: 8124
  servlet:
    context-path: /api
    # 30 days expire
    session:
      cookie:
        max-age: 2592000
# springdoc-openapi
springdoc:
  group-configs:
    - group: 'default'
      packages-to-scan: com.yupi.yuaicodemother.controller
# knife4j
knife4j:
  enable: true
  setting:
    language: zh_cn
```

接下来迁移代码，包括：

-   aop/AuthInterceptor.java 权限拦截器
-   controller/UserController.java 用户控制器
-   service/UserService.java 和 service/impl/UserServiceImpl.java 用户服务及实现类
-   mapper/UserMapper.java 和对应的 XML 文件（注意 XML 文件中引入的 Mapper 路径）

创建主启动类，代码如下：

```java
@SpringBootApplication
@MapperScan("com.yupi.yuaicodeuser.mapper")
@ComponentScan("com.yupi")
@EnableDubbo
public class YuAiCodeUserApplication {
    public static void main(String[] args) {
        SpringApplication.run(YuAiCodeUserApplication.class, args);
    }
}
```

#### yu-ai-code-ai AI 代码生成服务（模块）

方案设计阶段提到过，综合考虑开发复杂度、以及 ⁠Dubbo 的序列化机制不支持⁠ Reactor 的 Flux 类型，AI 模块不能单独作为服务调用，而是以依赖的方式引入。

编写依赖配置，包括 LangChain4j 相关的依赖：

```xml
<dependencies>
    <!-- LangChain4j -->
    <dependency>
        <groupId>dev.langchain4j</groupId>
        <artifactId>langchain4j-open-ai-spring-boot-starter</artifactId>
        <version>1.1.0-beta7</version>
    </dependency>
    <dependency>
        <groupId>dev.langchain4j</groupId>
        <artifactId>langchain4j-reactor</artifactId>
        <version>1.1.0-beta7</version>
    </dependency>
    <dependency>
        <groupId>dev.langchain4j</groupId>
        <artifactId>langchain4j-community-redis-spring-boot-starter</artifactId>
        <version>1.1.0-beta7</version>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

然后迁移代码，内容包括：

-   dev.langchain4j/ LangChain4j 源码修改
-   ai/guardrail/ AI 护轨相关代码
-   ai/model/ AI 模型相关代码
-   ai/tools/ AI 工具相关代码
-   ai/ 所有 AI Service（不迁移工厂类）
-   config/ 和 AI 模型相关的配置
-   resources/prompt/ 提示词文件

考虑到可观测性是独立学习的章节，不迁移可观测性的 monitor⁠ 包，因此要修改 StreamingCha⁠tModelConfig 和 ReasoningStreamingChatModelConfig 类，移除监听器。

#### yu-ai-code-app 应用服务

应用服务是最复杂的服务，它的⁠依赖配置包括分布式⁠限流、缓存、Session、数据访问等：

```xml
<dependencies>
    <!-- Redisson for distributed rate limiting -->
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>3.50.0</version>
    </dependency>
    <dependency>
        <groupId>com.github.ben-manes.caffeine</groupId>
        <artifactId>caffeine</artifactId>
    </dependency>
    <!-- Spring Session + Redis -->
    <dependency>
        <groupId>org.springframework.session</groupId>
        <artifactId>spring-session-data-redis</artifactId>
    </dependency>
    <!-- 必须引入，才能共享 Session -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
      <exclusions>
        <exclusion>
          <artifactId>lettuce-core</artifactId>
          <groupId>io.lettuce</groupId>
        </exclusion>
      </exclusions>
    </dependency>
    <dependency>
      <groupId>redis.clients</groupId>
      <artifactId>jedis</artifactId>
    </dependency>
    <!-- 数据访问 -->
    <dependency>
        <groupId>com.mybatis-flex</groupId>
        <artifactId>mybatis-flex-spring-boot3-starter</artifactId>
        <version>1.11.0</version>
    </dependency>
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-client</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-ai</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

修改配置文件，包含应用信息、⁠Session 配⁠置、数据库配置、Redis 配置、AI 模型配置等：

```yaml
spring:
  application:
    name: yu-ai-code-app
  # session
  session:
    store-type: redis
    # 30 days expire
    timeout: 2592000
  # mysql
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/yu_ai_code_mother
    username: root
    password: 123456
  # redis
  data:
    redis:
      host: localhost
      port: 6379
      database: 0
      password:
      ttl: 3600
server:
  port: 8125
  servlet:
    context-path: /api
    # 30 days expire
    session:
      cookie:
        max-age: 2592000
# AI
langchain4j:
  open-ai:
    chat-model:
      base-url: https://api.deepseek.com
      api-key: <Your API Key>
      model-name: deepseek-chat
      max-tokens: 8192
      log-requests: true
      log-responses: true
    streaming-chat-model:
      base-url: https://api.deepseek.com
      api-key: <Your API Key>
      model-name: deepseek-chat
      max-tokens: 8192
      log-requests: true
      log-responses: true
    # 推理 AI 模型配置（用于复杂的推理任务）
    reasoning-streaming-chat-model:
      base-url: https://api.deepseek.com
      api-key: <Your API Key>
      model-name: deepseek-reasoner
      max-tokens: 32768
      temperature: 0.1
      log-requests: true
      log-responses: true
    # 智能路由 AI 模型配置
    routing-chat-model:
      base-url: https://dashscope.aliyuncs.com/compatible-mode/v1
      api-key: <Your API Key>
      model-name: qwen-turbo
      max-tokens: 100
      log-requests: true
      log-responses: true
# springdoc-openapi
springdoc:
  group-configs:
    - group: 'default'
      packages-to-scan: com.yupi.yuaicodemother.controller
# knife4j
knife4j:
  enable: true
  setting:
    language: zh_cn
```

接下来迁移代码：

-   ai/ AI 服务工厂类（AiCodeGeneratorServiceFactory.java、AiCodeGenTypeRoutingServiceFactory.java）
    
-   config/ 缓存配置（RedisCacheManagerConfig.java）
    
-   controller/ 控制器层（AppController.java、ChatHistoryController.java、StaticResourceController.java）
    
-   core/ 代码生成核心代码
    
-   mapper/ 数据访问层（AppMapper.java、ChatHistoryMapper.java）
    
-   ratelimit/ 限流模块
    
-   service/ 业务服务层（AppService.java、ChatHistoryService.java、ProjectDownloadService.java 及其实现类）
    
-   resources/mapper/ MyBatis 映射文件
    

新建主启动类：

```java
@SpringBootApplication(exclude = {RedisEmbeddingStoreAutoConfiguration.class})
@MapperScan("com.yupi.yuaicodemother.mapper")
@EnableCaching
public class YuAiCodeAppApplication {
    public static void main(String[] args) {
        SpringApplication.run(YuAiCodeAppApplication.class, args);
    }
}
```

修改 AppServiceI⁠mpl 的代码，移⁠除可观测性配置：

```java
// 5. 通过校验后，添加用户消息到对话历史
chatHistoryService.addChatMessage(appId, message, ChatHistoryMessageTypeEnum.USER.getValue(), loginUser.getId());
// 6. 调用 AI 生成代码（流式）
Flux<String> codeStream = aiCodeGeneratorFacade.generateAndSaveCodeStream(message, codeGenTypeEnum, appId);
// 7. 收集 AI 响应内容并在完成后记录到对话历史
return streamHandlerExecutor.doExecute(codeStream, chatHistoryService, appId, loginUser, codeGenTypeEnum);
```

重点来了，在代码迁移过程中，需要修改调用了其他服务的代码（比如截图服务）。可以先使用 `@Lazy` 注解代替实际引入，后续会通过 Dubbo 进行服务调用：

```java
@Resource
@Lazy
private InnerScreenshotService screenshotService;
```

类似的，修改所有调用了 UserS⁠ervice 的代码，⁠替换为调用 InnerUserService 的实例方法或静态方法：

```java
@Resource
@Lazy
private InnerUserService userService;

// 调用实例方法
User user = userService.getById(userId);
UserVO userVO = userService.getUserVO(user);

// 调用静态方法
User loginUser = InnerUserService.getLoginUser(request);
```

#### yu-ai-code-screenshot 网页截图服务

网页截图服务的依赖配置相对简单：

```xml
<dependencies>
    <!-- Selenium 网页截图依赖 -->
    <dependency>
        <groupId>org.seleniumhq.selenium</groupId>
        <artifactId>selenium-java</artifactId>
        <version>4.33.0</version>
    </dependency>
    <dependency>
        <groupId>io.github.bonigarcia</groupId>
        <artifactId>webdrivermanager</artifactId>
        <version>6.1.0</version>
    </dependency>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-ai-code-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

修改配置文件，包括应用信息和 COS 对象存储配置：

```yaml
spring:
  application:
    name: yu-ai-code-screenshot
server:
  port: 8127
  servlet:
    context-path: /api
# 添加 COS 对象存储配置（需要从腾讯云获取）
cos:
  client:
    host: your-custom-domain.com
    secretId: your-secret-id
    secretKey: your-secret-key
    region: your-region
    bucket: your-bucket-name
```

接下来迁移代码：

-   utils/WebScreenshotUtils.java 网页截图工具类
-   service/ScreenshotService.java 截图服务和实现类

新增主启动类：

```java
@SpringBootApplication
public class YuAiCodeScreenshotApplication {
    public static void main(String[] args) {
        SpringApplication.run(YuAiCodeScreenshotApplication.class, args);
    }
}
```

完成所有模块的构建后，可以用⁠ Maven 执行⁠父项目的整体打包，确保所有模块都能成功编译。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/MssDcHd2Y13J1NDu.webp)

## 四、Nacos + Dubbo 服务间调用

前面我们已经介绍了注册中心和服⁠务调用的基本概念，接⁠下来我们利用 Nacos 和 Dubbo 来实现微服务间的通信。

### Nacos 安装

[Nacos](https://nacos.io/docs/v2.3/what-is-nacos) 是我们选择的服务注册中心和配置中心，负责管理所有微服务的注册发现和配置信息。

根据 [版本兼容性要求](https://sca.aliyun.com/docs/2023/overview/version-explain)，我们必须选择 Nacos `v2.3.2` 版本。可以从 [Nacos 官方网站下载](https://nacos.io/download/release-history) 对应版本的安装包。

解压后，进入 bin 目录运⁠行以下命令：   ⁠                             

```bash
# Windows
startup.cmd -m standalone

# Linux / Mac
sh startup.sh -m standalone
```

看到输出信息，表示启动成功：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/y45ZJBAtfHH35lKr.webp)

启动成功后，可以访问 [http://localhost:8848/nacos](http://localhost:8848/nacos) 进入 Nacos 控制台：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/mrhDAXcFOel1RxzC.webp)

如果需要账号密码的话，默认都是 nacos。

### 服务调用关系分析

在我们的微服务架构中，服务间⁠的调用关系并不复杂⁠，主要是 2 类：

1）用户服务被调用的接口（主要是应用服务调用）

包括获取用户信息、批量获取用⁠户信息、获取用户 ⁠VO、获取当前登录用户（改为静态方法）等。

2）应用服务调用其他服务

调用用户服务进行用户信息查询⁠和权限验证，调用截⁠图服务生成应用封面图。

### 引入 Dubbo

[Dubbo](https://cn.dubbo.apache.org/zh-cn/) 是阿里开源的高性能 RPC 框架，它提供了面向接口的远程方法调用、容错和负载均衡，以及服务自动注册和发现等功能。

注意，它的作用和 Spring Cloud 是类似的，都能实⁠现服务发现和治理，项目中使用一个就可⁠以了。和 Spring Cloud 的 HTTP 调用相比，Dubbo 基于 TCP 等协议，具有更高的性能和更低的延迟。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/GHBXutvTD2UuQLFq.webp)

首先在父项目中定义 Dubbo 的依赖版本：

```xml
<properties>
    <dubbo.version>3.3.0</dubbo.version>
</properties

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.apache.dubbo</groupId>
            <artifactId>dubbo-bom</artifactId>
            <version>${dubbo.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

之后要在每个需要服务间调用的⁠微服务中添加 Du⁠bbo 依赖，包括用户服务、应用服务、截图服务：

```xml
<!-- Dubbo -->
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo-spring-boot-starter</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo-nacos-spring-boot-starter</artifactId>
</dependency>
```

### 用户服务

在用户服务中，我们需要提供服⁠务给其他微服务⁠调用。首先引入依赖：

```xml
<!-- Dubbo -->
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo-spring-boot-starter</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo-nacos-spring-boot-starter</artifactId>
</dependency>
<dependency>
    <groupId>com.yupi</groupId>
    <artifactId>yu-ai-code-client</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

在配置文件中添加 Dubbo 配置：

```yaml
# Dubbo
dubbo:
  registry:
    address: nacos://127.0.0.1:8848?username=nacos&password=nacos
    register-mode: instance
  protocol:
    name: tri
    port: 50051
  consumer:
    timeout: 60000
  provider:
    timeout: 60000
```

编写服务实现类，使用 `@DubboService` 注解标记，作为一个可被发现的服务：

```java
@DubboService
public class InnerUserServiceImpl implements InnerUserService {

    @Resource
    private UserService userService;

    @Override
    public List<User> listByIds(Collection<? extends Serializable> ids) {
        return userService.listByIds(ids);
    }

    @Override
    public User getById(Serializable id) {
        return userService.getById(id);
    }

    @Override
    public UserVO getUserVO(User user) {
        return userService.getUserVO(user);
    }
}
```

在启动类中添加 @EnableDubbo 注解：

```java
@SpringBootApplication
@EnableDubbo
@MapperScan("com.yupi.yuaicodemother.mapper")
public class YuAiCodeUserApplication {
    public static void main(String[] args) {
        SpringApplication.run(YuAiCodeUserApplication.class, args);
    }
}
```

启动用户服务后，可以在 Nac⁠os 中看到服务信息⁠：                                

![](https://pic.code-nav.cn/course_picture/1608440217629360130/2THPMLEYZB8EuOrO.webp)

![](https://pic.code-nav.cn/course_picture/1608440217629360130/EkVoEGf3ivCM12jp.webp)

### 截图服务

先引入依赖：

```xml
<!-- Dubbo -->
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo-spring-boot-starter</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo-nacos-spring-boot-starter</artifactId>
</dependency>
<dependency>
    <groupId>com.yupi</groupId>
    <artifactId>yu-ai-code-client</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

然后修改配置，与用户服务的配⁠置类似，区别是端口⁠不同，而且由于截图操作比较耗时，将超时时间设置为 120 秒：

```yaml
# Dubbo
dubbo:
  registry:
    address: nacos://127.0.0.1:8848?username=nacos&password=nacos
    register-mode: instance
  protocol:
    name: tri
    port: 50052
  consumer:
    timeout: 120000
  provider:
    timeout: 120000
```

编写服务实现类：

```java
@DubboService
@Slf4j
public class InnerScreenshotServiceImpl implements InnerScreenshotService {

    @Resource
    private ScreenshotService screenshotService;

    @Override
    public String generateAndUploadScreenshot(String webUrl) {
        return screenshotService.generateAndUploadScreenshot(webUrl);
    }
}
```

启动类增加 Dubbo 注解：

```java
@SpringBootApplication
@EnableDubbo
public class YuAiCodeScreenshotApplication {
    public static void main(String[] args) {
        SpringApplication.run(YuAiCodeScreenshotApplication.class, args);
    }
}
```

启动服务，在 Nacos 中看到服务注册成功：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/c7gce5sVnzQT8a07.webp)

### 应用服务

先引入依赖：

```xml
<!-- Dubbo -->
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo-spring-boot-starter</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo-nacos-spring-boot-starter</artifactId>
</dependency>
```

应用服务作为服务消费者，需要⁠调用其他服务，也需⁠要添加 Dubbo 配置：

```yaml
# Dubbo
dubbo:
  registry:
    address: nacos://127.0.0.1:8848?username=nacos&password=nacos
    register-mode: instance
  protocol:
    name: tri
    port: 50053
  consumer:
    timeout: 120000
  provider:
    timeout: 120000
```

修改所有 InnerService 的引用，使用 `@DubboReference` 注解注入远程服务：

```java
@DubboReference
private InnerUserService userService;

@DubboReference
private InnerScreenshotService screenshotService;
```

`@DubboReference` 是 Dubbo 框架提供的服务消费者注解，用于自动注入远程服务的代理对象。当 Spring 容器启动时，Dubbo 会根据注解信息从 Nacos 注册中心查找对应的服务提供者地址，然后创建代理对象注入到当前服务中。通过这个代理对象调用方法时，Dubbo 会自动将调用请求通过网络发送到远程服务，并将结果返回给调用方，整个过程对开发者来说 **就像调用本地方法一样简单**。

启动类增加 Dubbo 注解：

```java
@SpringBootApplication(exclude = {RedisEmbeddingStoreAutoConfiguration.class})
@MapperScan("com.yupi.yuaicodemother.mapper")
@EnableDubbo
@EnableCaching
public class YuAiCodeAppApplication {
    public static void main(String[] args) {
        SpringApplication.run(YuAiCodeAppApplication.class, args);
    }
}
```

启动应用服务成功：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/MPr3W1L1YdDwTHc6.webp)

通过接口文档测试创建应用接口⁠和获取精选应用列表⁠接口，可以验证服务间调用是否正常工作。

发现成功调用到了内部服务： ⁠         ⁠                      

![](https://pic.code-nav.cn/course_picture/1608440217629360130/5ZGHpnVschbJZX5C.webp)

需要注意的是，在微服务拆分后⁠，Spring C⁠ache 的条件判断可能会失效，比如：

```java
@Cacheable(
        value = "good_app_page",
        key = "T(com.yupi.yuaicodemother.utils.CacheKeyUtils).generateKey(#appQueryRequest)",
        condition = "#appQueryRequest.pageNum <= 10"
)
```

这是一个常见的 Spring Cache + 微服务的问题。微服⁠务拆分后，AOP 拦截器的执行顺序可能发生⁠变化，Cache 拦截器可能比 RequestBody 解析更早执行，因此 SpEL 表达式无法正确解析请求参数。

要解决这个问题，可以注释掉 condition⁠ 或者使用 unless 替代⁠ condition，因为 unless 是在方法执行后判断（这时参数已解析完成）。

___

目前各个服务已经开发完成，但是现在的问题是：

1.  前端不方便调用
2.  无法进行用户权限校验
3.  只能单独查看某个服务的接口文档

下面我们分别尝试解决这些问题。

## 五、Higress 微服务网关

前面我们已经介绍了微服务网关的基本概念，接下来我们重点介绍如何使用 [Higress](https://higress.cn/) 来构建高性能的 [AI 原生 API 网关](https://higress.cn/docs/latest/overview/what-is-higress/)。

作为系统的统一入口，Higr⁠ess 网关为我们⁠提供了以下核心能力：

-   统一入口：为所有微服务提供统一的访问入口，简化客户端的调用复杂度。
-   请求路由：根据请求的路径、参数等信息，将请求路由到正确的微服务实例。
-   负载均衡：在多个服务实例之间分发请求，提高系统的可用性和性能。
-   安全认证：统一处理身份验证、权限控制等安全相关功能。
-   限流熔断：实现请求限流、服务熔断等保护机制，防止系统过载。
-   监控日志：收集请求日志、监控指标等信息，便于系统运维和问题排查

![](https://pic.code-nav.cn/course_picture/1608440217629360130/o1I5urVvDBRXdvEY.webp)

### Higress 安装

Higress 的安装需要 ⁠Docker 环境⁠支持，如果没有安装 Docker 的话，必须先安装！

推荐直接 [安装 Docker Desktop](https://www.docker.com/products/docker-desktop/)，会自动安装 Docker 以及可视化管理软件。

但是要注意，Windows 上想运行 Docker 的话，必须要安装 WSL（Linux 子系统），[参考安装文档](https://learn.microsoft.com/zh-cn/windows/wsl/install)。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/npMgMqBwDTBuxKOY.webp)

不过由于安装时可能会出现“与服务器的连接被重置”，鱼皮建议大家直接到 [GitHub 下载 WSL 安装包](https://github.com/microsoft/WSL/releases)：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/RZXydERc6VyR18uy.webp)

注意，如果实在无法安装 WSL，也可以用虚拟机软件，参考 [编程导航 OJ 在线判题项目](https://www.codefather.cn/course/1790980707917017089)。

安装好 Docker 后，可⁠以使用以下命令在本⁠地启动 Higress：

```shell
docker run -d --rm --name higress-ai -v ${PWD}:/data -e O11Y=on \
        -p 8001:8001 -p 8080:8080 -p 8443:8443  \
        higress-registry.cn-hangzhou.cr.aliyuncs.com/higress/all-in-one:latest
```

监听端口说明：

-   8001 端口：Higress UI 控制台入口
-   8080 端口：网关 HTTP 协议入口
-   8443 端口：网关 HTTPS 协议入口

可以用 `docker ps` 命令查看启动状态：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Hek50P3vxnIphB66.webp)

Docker Desktop 中能看到运行的容器：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/mQkoNMFdSZ5f8W9Q.webp)

启动成功后，可以通过 800⁠1 端口访问 Hi⁠gress 控制台：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/QhirbmThoW0Dn14j.webp)

### 服务来源配置

在 Higress 控制台中⁠配置服务来源，可以⁠从 Nacos 中获取服务来源：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/V78os1nWqpJdGuma.webp "null")

需要注意的是，注册中心地址不⁠支持 127.0.⁠0.1 或 localhost，需要使用本机的内网地址。

Windows 系统通过 `ipconfig` 命令查看：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/TpuQH6dKZVLF4y49.webp)

Mac 系统可以直接在网络设置中查看：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/coGMn7P7UAnJgNdi.webp)

配置完成后，Higress ⁠会自动发现在 Na⁠cos 中注册的所有微服务：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/CbXU0Mifj5GFDfFF.webp)

但是 Dubbo + Nacos 默认只注册 Dubbo 服务（RPC接口），而不注册 HTTP 接口。我们对外提供的服务都没有被发现，需要手动注册：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/mmNP32Q8zg2ubgz4.webp)

所有服务注册完成：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/7wyta6AolF2Qf4Wl.webp)

### 路由配置

手动配置路由规则，为每个服务创建对应的路由：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/aZQyG7KlYZWMgDG6.webp)

选择对应的服务并配置路由规则：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/H6lQbSPDGS0gTURY.png)

这样一来，前端只需要访问网关的地址 `localhost:8080/api/user/xxx`，就会自动转发到对应的服务 `localhost:8124/api/user/xxx`。

路由配置完成：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/9z3iPkV4XKnkNuSk.webp)

完成路由配置后，需要修改前端 vite ⁠请求代理地址为 8080 ⁠端口，然后就可以利用前端来测试完整业务流程了，能正常登录和生成网站就说明配置成功。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/OhqGMxgPqvsPllse.webp)

💡 如果你使用了 Spring Cloud 作为服务发现（而不是 Dubbo），可以 [整合 Nacos 快速发现服务](https://nacos.io/docs/latest/ecology/use-nacos-with-spring-cloud)。

### 插件配置

Higress 提供了丰富的⁠插件功能，可以满足⁠不同场景的需求。给大家分享一些典型的场景：

#### CORS 跨域配置

可以全局配置 CORS 跨域支持：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/EYkuOBJB70ldJhKf.webp)

支持表单填写或者 YAML 配置文件：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/93bfEyc8AwtHBJ65.webp)

也可以单独针对某个路由配置跨域插件：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/hwtRrnIwAPCTAkjm.webp)

如图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/byueUir8Ak0kQn99.webp)

![](https://pic.code-nav.cn/course_picture/1608440217629360130/4o0SLh1i9UotZYR7.webp)

#### 权限认证插件

Higress 提供了多种权限认证插件：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/w5hu2NPuxwlIzyNS.webp)

比如 Key 认证是一个典型⁠的 API 认证场⁠景（想想调用 AI 时输入的 API Key）：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/uPZQfuJcoDE9aEDu.webp)

#### 安全性插件

可以配置 IP 限制、请求屏蔽等安全插件：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/G04GnWouM2Ntfh9q.webp)

比如限制禁止某个 IP 访问：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/1IGJUG5rIAjdwmtT.webp)

还可以利用请求屏蔽插件提高安全性。测试一下，禁止访问 `/api/user/get/login` 接口：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/EuhqM5gExjIdCvh8.webp)

配置后该接口会返回 404，⁠因为被网关拦截了，⁠都到不了用户服务：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/9PDeph8E6cgF6gow.webp)

#### 限流插件

还可以配置限流插件，在网关层面控制请求频率：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/xNlDg7znBYmXFH0X.webp)

比较常用的是基于 Key 进行限流⁠，Key 可以从请求头⁠或 URL 参数中获取，比如根据请求参数中的 appId 限流。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/DnG0pmbonyZE6BhY.webp)

## 六、更多操作

### 权限认证问题解决

在微服务改造过程中，我们发现⁠之前的 AOP 鉴⁠权没有生效，因为只有用户模块有 AOP 鉴权类。

比如未登录时调用管理员查询对话历史接口，发现也能调用：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/dNdasGhTfFBlttQh.webp)

如果我们使用的是 Spring Cloud G⁠ateway，可以在项目入口处⁠自定义鉴权逻辑。但现在 Higress 是独立的组件，很难编写和已有项目集成的自定义逻辑。

怎么办呢？

`aop/AuthInterceptor` 是一个有点儿特殊的类，由于依赖了 UserService 和 User 实体类，无法放到 common 包中。如果单独存放在用户模块，其他服务想要使用就得引入用户模块（违背了微服务的原则），所以比较快速的解决方案是，后续每个需要鉴权的服务单独复制这个类即可。

比如在应用模块中引入：

```java
@Aspect
@Component
public class AuthInterceptor {
    
    /**
     * 执行拦截
     *
     * @param joinPoint 切入点
     * @param authCheck 权限校验注解
     */
    @Around("@annotation(authCheck)")
    public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable {
        String mustRole = authCheck.mustRole();
        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();
        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
        // 当前登录用户
        User loginUser = InnerUserService.getLoginUser(request);
        UserRoleEnum mustRoleEnum = UserRoleEnum.getEnumByValue(mustRole);
        // 不需要权限，放行
        if (mustRoleEnum == null) {
            return joinPoint.proceed();
        }
        // 以下为：必须有该权限才通过
        // 获取当前用户具有的权限
        UserRoleEnum userRoleEnum = UserRoleEnum.getEnumByValue(loginUser.getUserRole());
        // 没有权限，拒绝
        if (userRoleEnum == null) {
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
        }
        // 要求必须有管理员权限，但用户没有管理员权限，拒绝
        if (UserRoleEnum.ADMIN.equals(mustRoleEnum) && !UserRoleEnum.ADMIN.equals(userRoleEnum)) {
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
        }
        // 通过权限校验，放行
        return joinPoint.proceed();
    }
}
```

再次测试，发现鉴权注解生效了：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/OBdRHeD6VcXt2WU5.webp)

💡 如果需要鉴权的服务较多，⁠更优雅的方式是写一个⁠单独的鉴权服务，感兴趣的同学可以了解下 OAuth2 协议。

同时，我们可以利用 Higress⁠ 插件的请求屏蔽和认证⁠机制，组合使用 Higress + 服务内鉴权，实现多层次的安全防护。

### 接口文档聚合

在微服务架构中，每个服务都有⁠自己的接口文档，为⁠了方便查看和管理，我们可以考虑接口文档聚合。

Knife4j 提供了 [接口文档聚合功能](https://doc.xiaominfo.com/docs/middleware-sources/aggregation-cloud)，支持 Cloud 模式自己填写要聚合的服务地址配置；也支持跟 Higress 网关一样，采用 Nacos 模式自动发现。

但很坑的是，这种方式只支持 ⁠Spring Bo⁠ot 2，Spring Boot 3 根本无法启动！

![](https://pic.code-nav.cn/course_picture/1608440217629360130/i74EWb1OpgFbCJBR.webp)

作为替代方案，可以考虑自己写⁠一个导航网站（用 ⁠AI 生成即可），点击某个服务后就跳转到对应的接口文档页面。

### 项目部署

微服务项目的部署相比单体应用⁠更加复杂，需要考虑⁠多个服务的协调启动、服务发现、配置管理等问题。

推荐使用 Docker Compose 编排所有依赖（比如 MySQL）和微服务容器的启动，而不是人工一个个启动服务，在 [编程导航的 OJ 判题项目](https://www.codefather.cn/course/1790980707917017089) 中带大家实战过这种方式的部署，建议学习。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/cYh0NUh0yKllzPpA.webp)

## 七、扩展思路

注意，下面这些只是给大家分享⁠一些微服务项目的扩⁠展思路，目前没必要刻意实现，等有实际需要了再操作就好。

1）服务治理优化：实现服务限流、添加服务熔断、配置服⁠务降级、实现灰度发布等功能。可以基⁠于 Sentinel 或 Hystrix 实现熔断降级，使用 Dubbo 的路由规则实现灰度发布。

2）链路追踪系统：集成 SkyWalking 或 Z⁠ipkin 实现分布式追踪，可视化⁠服务调用链路，快速定位性能瓶颈和异常问题。编程导航的手写 RPC 框架项目中有详细的链路追踪实现。

3）配置中心改造：使用 Nacos ⁠Config 统一管理所⁠有服务配置，实现配置热更新，避免重启服务。可以按环境、按服务进行配置隔离。

4）监控告警体系：建立完善的 Prometheus + Grafana + AlertManager 监控告警体系，监控 JVM 指标、业务指标、接口响应时间等，及时发现和处理问题。

5）数据库拆分：随着业务发展，可以⁠将用户服务和应用服务的⁠数据库进行拆分，每个服务使用独立的数据库，提高数据隔离性和扩展能力。

6）消息队列引入：对于一些异步处理场景，⁠如代码生成完成后的通知、应⁠用统计数据更新等，可以引入 RocketMQ 或 Kafka 实现异步解耦。

## 总结

通过本节的学习，我们成功将 AI 零代码应用生成平台从单体架构改造为微服务架构。从服务拆分设计到实际编码实现，从 Nacos + Dubbo 服务调用到 Higress 网关配置，完整体验了微服务架构的构建过程。

希望大家掌握这些微服务改造的套路和技巧，能够根据实际业务需求合理拆分服务，构建高可用、可扩展的分布式系统。记住最重要的原则：**不能拆的不要硬拆，要根据业务复杂度和团队能力循序渐进地演进架构。**

至此，本项目结束，鱼皮捡起了地上成堆的头发⁠，叹了口气，据说收到大家靠这⁠个项目拿到的 Offer 报喜后，鱼皮的头发就会长回来。大家加油，我期待着那一天！


