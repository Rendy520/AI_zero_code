---
source: https://www.codefather.cn/course/1948291549923344386/section/1953297401593405442
---

# 8 - 功能扩展 - 【大厂必备】LangChain4j + 工作流

## 本节重点

之前我们已经实现了 AI 零⁠代码应用生成平台的⁠核心功能，用户可以通过简单的对话生成各种类型的前端应用。

本节我们将继续为平台扩展更多功能：

-   生成应用封面图
-   下载项目代码包
-   AI 智能选择方案

通过本节的学习，你将掌握网页⁠截图、文件下载、A⁠I 智能路由等技术。

## 一、生成应用封面图

### 需求分析

如果每个应用都有一个精美的预⁠览图，会让整个平台⁠看起来更加专业和吸引人。

参考其他的大厂平台，可以直接将网站⁠的实际运行效果作为应用⁠封面图，做到所见即所得；而且应该要自动生成，总不能让管理员手动截图吧？

![](https://pic.code-nav.cn/course_picture/1608440217629360130/JbAZah1AwqvZY2yD.webp)

### 方案设计

#### 实现流程

实现应用封面图生成功能，我们需要考虑几个关键步骤：

1）首先要获取到应用的可访问 URL。由于我们的平台支持多种生成模式（原生 HTML、多文件项目、Vue 工程），其中原生模式和 Vue 工程模式生成可访问浏览 URL 的时机不一样。所以为了统一处理，而且确保应用已经可以正常访问，我们选择在 **应用部署完成后再生成封面图**。

2）使用 [Selenium](https://www.selenium.dev/zh-cn/documentation/) 这样的自动化工具打开一个无头浏览器，访问应用页面并进行截图。

3）直接截图得到的图片通常比⁠较大，不仅占用存储⁠空间，加载速度也会比较慢。因此我们需要对图片进行压缩处理。

虽然我们可以通过调整 Selenium 的⁠窗口大小来控制截图尺寸，但这⁠样可能会导致页面显示不全。更好的方案是先按正常尺寸截图，然后使用工具库对图片进行压缩。

4）为了确保图片的持久化存储和快速访⁠问，将压缩后的图片上传到⁠腾讯云 COS 对象存储中，并将访问 URL 保存到数据库的应用表中。

5）最后，记得清理本地临时文件。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/kxFctTy1ASQ3vLA8.webp)

#### 网页截图方案选型

在选择网页截图技术方案时，我⁠们需要综合考虑多个⁠因素。市面上有很多可选的技术，每种都有自己的优缺点：



|评估维度|Selenium|Playwright|HtmlUnit|Puppeteer + Node.js|云服务API|
|---|---|---|---|---|---|
|依赖大小|~50MB|~100MB|~30MB|~200MB|0MB|
|启动时间|3-5秒|1-2秒|<1秒|2-3秒|网络延迟|
|内存占用|200-500MB|100-300MB|20-50MB|150-400MB|0MB|
|CPU占用|中等|较低|很低|中等|无|
|截图质量|⭐⭐⭐⭐⭐|⭐⭐⭐⭐⭐|⭐⭐|⭐⭐⭐⭐⭐|⭐⭐⭐⭐|
|JS执行|完整支持|完整支持|有限支持|⁠完整支持|完整支持|
|Vue/React支持|⭐⭐⭐⭐⭐|⭐⭐⭐⭐⭐|⭐⭐|⭐⭐⭐⭐⭐|⭐⭐⭐⭐|
|跨浏览器|Chrome/Firefox/Edge|Chrome/Firefox/Safari|模拟浏览器|仅Chrome系 ⁠|多种选择|
|配置复杂度|⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐⭐⭐|⭐⭐⭐|⭐⭐⭐⭐⭐|
|学习成本|⭐⭐⭐⭐|⭐⭐⭐|⭐⭐⭐⭐⭐|⭐⭐⭐|⭐⭐⭐⭐⭐|
|社区活跃度|⭐⭐⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐|⭐⭐⭐⭐⭐|服务商决定|
|文档完善度|⭐⭐⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐|⭐⭐⭐⭐⭐|服务商决定|
|错误处理|⭐⭐⭐⭐|⭐⭐⭐⭐⭐|⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐|
|并发支持|⭐⭐⭐⭐|⭐⭐⭐⭐⭐|⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐⭐⭐|
|企业采用| 广泛使用|快速增长|传统项目|广泛使用|成本敏感|
|总体推荐度|⭐⭐⭐⭐⭐|⭐⭐⭐⭐|⭐⭐|⭐⭐⭐|⭐⭐|

通过对比可以看出，HtmlUnit 虽然轻量，但对 ⁠JS 的支持度有限，这在现代前端应⁠用中是一个致命问题。如果我们选择了它，可能到后面才发现很多应用的封面生成不了，再换技术就得不偿失了。

其他几种方案就要根据实际需求来选择了，追求稳定性选 Selenium，追求性能选 Playwright，如果用 Node.js 技术栈就选 Puppeteer，有充足预算就选云服务 API。

**考虑到我们是 Java 技术栈，以及对稳定性的要求，最终选择 Selenium。**

#### 什么是 Selenium？

Selenium 是一个非常⁠成熟的 Web 自⁠动化框架，它的核心概念是 WebDriver（浏览器驱动）。

WebDriver 是一个可以控制⁠浏览器行为的接口，能够⁠让程序像人类一样操作浏览器：打开页面、点击按钮、输入文本、截取屏幕等。

可以说 WebDriver 是 Selenium 与浏览器之间的桥梁，因为不同浏览⁠器（Chrome、Firefox、Safari 等）有⁠不同的内部 API 和控制机制，驱动程序负责将 Selenium 的标准化命令翻译成各个浏览器能理解的具体指令，从而实现跨浏览器的统一自动化控制。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/qfIPNlax9NPTQIUm.webp)

[Selenium 的官方文档](https://www.selenium.dev/zh-cn/documentation/) 非常友好，还提供了中文版本，而且代码也是 [开源](https://github.com/SeleniumHQ/selenium) 的，生态不错。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/sF0IJpDZkolSJtmG.webp)

在实际使用 Selenium 时，最好搭配 [WebDriverManager](https://github.com/bonigarcia/webdrivermanager) 使用。WebDriverManager 是一个自动管理浏览器驱动程序的工具库，它解决了很多实际开发中的痛点：

1.  自动下载驱动程序：根据系统上安装的浏览器版本，自动下载对应的驱动程序
2.  版本匹配：确保驱动程序版本与浏览器版本兼容
3.  路径管理：自动设置系统属性，告诉 Selenium 驱动程序的位置
4.  缓存机制：下载的驱动程序会被缓存，避免重复下载



|对比项|使用 WebDriverManager|不使用 WebDriverManager|
|---|---|---|
|配置复杂度|一行代码搞定|需要手动下载、配置路径|
|版本管理|自动匹配最佳版本|手动检查和更新|
|跨平台支持|自动适配⁠操作系统|需要为每个平台准备驱动|
|CI/CD ⁠友好|开箱即用|需要额外脚本处理|
|维护成本|几乎为零|需要定期更新|
|错误处理|自动重试和降级|需要手动处理各种异常|

官方也是推荐使用 WebDr⁠iverManag⁠er 来管理驱动：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/z0WFlq8DP9eUS11O.webp "null")

### 开发实现

接下来，我们依次开发实现下列功能：

1.  本地生成截图
2.  保存截图到对象存储
3.  截图服务
4.  触发截图生成

#### 1、本地生成截图

首先，我们需要在项目中引入必要的依赖：

```xml
<!-- Selenium 网页截图依赖 -->
<dependency>
    <groupId>org.seleniumhq.selenium</groupId>
    <artifactId>selenium-java</artifactId>
    <version>4.33.0</version>
</dependency>
<dependency>
    <groupId>io.github.bonigarcia</groupId>
    <artifactId>webdrivermanager</artifactId>
    <version>6.1.0</version>
</dependency>
```

接下来，我们在 `utils` 包下创建专门用于网页截图的工具类，提供根据 URL 生成截图文件并返回路径的方法。

1）第一步是初始化驱动。需要注意避免重复初始化驱动程序：

1.  在静态代码块里初始化驱动，确保整个应用生命周期内只初始化一次
2.  默认使用已经初始化好的驱动实例
3.  在项目停止前正确销毁驱动，释放资源

代码如下：

```java
@Slf4j
public class WebScreenshotUtils {

    private static final WebDriver webDriver;

    static {
        final int DEFAULT_WIDTH = 1600;
        final int DEFAULT_HEIGHT = 900;
        webDriver = initChromeDriver(DEFAULT_WIDTH, DEFAULT_HEIGHT);
    }

    @PreDestroy
    public void destroy() {
        webDriver.quit();
    }

    /**
     * 初始化 Chrome 浏览器驱动
     */
    private static WebDriver initChromeDriver(int width, int height) {
        try {
            // 自动管理 ChromeDriver
            WebDriverManager.chromedriver().setup();
            // 配置 Chrome 选项
            ChromeOptions options = new ChromeOptions();
            // 无头模式
            options.addArguments("--headless");
            // 禁用GPU（在某些环境下避免问题）
            options.addArguments("--disable-gpu");
            // 禁用沙盒模式（Docker环境需要）
            options.addArguments("--no-sandbox");
            // 禁用开发者shm使用
            options.addArguments("--disable-dev-shm-usage");
            // 设置窗口大小
            options.addArguments(String.format("--window-size=%d,%d", width, height));
            // 禁用扩展
            options.addArguments("--disable-extensions");
            // 设置用户代理
            options.addArguments("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36");
            // 创建驱动
            WebDriver driver = new ChromeDriver(options);
            // 设置页面加载超时
            driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(30));
            // 设置隐式等待
            driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
            return driver;
        } catch (Exception e) {
            log.error("初始化 Chrome 浏览器失败", e);
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "初始化 Chrome 浏览器失败");
        }
    }
}
```

这段代码看起来长，其实基本都是一些配⁠置，属于样板代码。其中比⁠较重要的是：                                

1.  无头模式运行：通过 `--headless` 参数，Chrome 浏览器在后台运行，不会弹出窗口。
2.  Docker 兼容性：添加了 `--no-sandbox` 和 `--disable-dev-shm-usage` 参数，确保在容器环境中正常运行。

💡 思考一下，上述代码存在⁠什么问题么？在本小⁠节扩展思路中会讲解。

2）编写一些子方法，比如保存图片到文件：

```java
/**
 * 保存图片到文件
 */
private static void saveImage(byte[] imageBytes, String imagePath) {
    try {
        FileUtil.writeBytes(imageBytes, imagePath);
    } catch (Exception e) {
        log.error("保存图片失败: {}", imagePath, e);
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "保存图片失败");
    }
}
```

压缩图片：

```java
/**
 * 压缩图片
 */
private static void compressImage(String originalImagePath, String compressedImagePath) {
    // 压缩图片质量（0.1 = 10% 质量）
    final float COMPRESSION_QUALITY = 0.3f;
    try {
        ImgUtil.compress(
                FileUtil.file(originalImagePath),
                FileUtil.file(compressedImagePath),
                COMPRESSION_QUALITY
        );
    } catch (Exception e) {
        log.error("压缩图片失败: {} -> {}", originalImagePath, compressedImagePath, e);
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "压缩图片失败");
    }
}
```

此处我选择压缩到 30% 质⁠量，清晰度还不错，⁠而且能大幅减少文件大小，大家可以按需调整。

等待页面加载完成：

```java
/**
 * 等待页面加载完成
 */
private static void waitForPageLoad(WebDriver driver) {
    try {
        // 创建等待页面加载对象
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        // 等待 document.readyState 为complete
        wait.until(webDriver ->
                ((JavascriptExecutor) webDriver).executeScript("return document.readyState")
                        .equals("complete")
        );
        // 额外等待一段时间，确保动态内容加载完成
        Thread.sleep(2000);
        log.info("页面加载完成");
    } catch (Exception e) {
        log.error("等待页面加载时出现异常，继续执行截图", e);
    }
}
```

不仅等待 DOM 完全加载，⁠还额外等待 2 秒⁠确保动态内容渲染完成。

3）最后编写完整的生成网页截图⁠方法，访问网页、等待⁠页面加载完成并截图、保存截图文件并压缩、最后返回压缩后的路径。

```java
/**
 * 生成网页截图
 *
 * @param webUrl 网页URL
 * @return 压缩后的截图文件路径，失败返回null
 */
public static String saveWebPageScreenshot(String webUrl) {
    if (StrUtil.isBlank(webUrl)) {
        log.error("网页URL不能为空");
        return null;
    }
    try {
        // 创建临时目录
        String rootPath = System.getProperty("user.dir") + File.separator + "tmp" + File.separator + "screenshots"
                + File.separator + UUID.randomUUID().toString().substring(0, 8);
        FileUtil.mkdir(rootPath);
        // 图片后缀
        final String IMAGE_SUFFIX = ".png";
        // 原始截图文件路径
        String imageSavePath = rootPath + File.separator + RandomUtil.randomNumbers(5) + IMAGE_SUFFIX;
        // 访问网页
        webDriver.get(webUrl);
        // 等待页面加载完成
        waitForPageLoad(webDriver);
        // 截图
        byte[] screenshotBytes = ((TakesScreenshot) webDriver).getScreenshotAs(OutputType.BYTES);
        // 保存原始图片
        saveImage(screenshotBytes, imageSavePath);
        log.info("原始截图保存成功: {}", imageSavePath);
        // 压缩图片
        final String COMPRESSION_SUFFIX = "_compressed.jpg";
        String compressedImagePath = rootPath + File.separator + RandomUtil.randomNumbers(5) + COMPRESSION_SUFFIX;
        compressImage(imageSavePath, compressedImagePath);
        log.info("压缩图片保存成功: {}", compressedImagePath);
        // 删除原始图片，只保留压缩图片
        FileUtil.del(imageSavePath);
        return compressedImagePath;
    } catch (Exception e) {
        log.error("网页截图失败: {}", webUrl, e);
        return null;
    }
}
```

4）编写单元测试来验证功能：

```java
@Slf4j
@SpringBootTest
public class WebScreenshotUtilsTest {

    @Test
    void saveWebPageScreenshot() {
        String testUrl = "https://www.codefather.cn";
        String webPageScreenshot = WebScreenshotUtils.saveWebPageScreenshot(testUrl);
        Assertions.assertNotNull(webPageScreenshot);
    }
}
```

能够在临时目录下看到截图文件：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/LrNBBkM65oY3yYYE.webp)

#### 2、保存截图到对象存储

为了让生成的封面图能够持久化⁠存储并快速访问，我⁠们需要将图片上传到腾讯云 COS 对象存储。

首先在 [腾讯云控制台](https://console.cloud.tencent.com/cos/bucket) 创建一个存储桶：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/9GR1W9xXbcFacN3g.webp)

注意认真看官方的提示，按需选择参数：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/eYM0iTmvCFv3MQ3f.webp)

创建成功后，在配置文件中添加 COS 相关配置（[密钥可以从这里获取](https://cloud.tencent.com/document/product/598/40488)）：

```yaml
# 添加 COS 对象存储配置（需要从腾讯云获取）
cos:
  client:
    host: your-custom-domain.com
    secretId: your-secret-id
    secretKey: your-secret-key
    region: ap-shanghai
    bucket: your-bucket-name
```

引入依赖：

```xml
<dependency>
     <groupId>com.qcloud</groupId>
     <artifactId>cos_api</artifactId>
     <version>5.6.227</version>
</dependency>
```

在 `config` 包下创建 COS 客户端配置类：

```java
/**
 * 腾讯云COS配置类
 * 
 * @author yupi
 */
@Configuration
@ConfigurationProperties(prefix = "cos.client")
@Data
public class CosClientConfig {

    /**
     * 域名
     */
    private String host;

    /**
     * secretId
     */
    private String secretId;

    /**
     * 密钥（注意不要泄露）
     */
    private String secretKey;

    /**
     * 区域
     */
    private String region;

    /**
     * 桶名
     */
    private String bucket;

    @Bean
    public COSClient cosClient() {
        // 初始化用户身份信息(secretId, secretKey)
        COSCredentials cred = new BasicCOSCredentials(secretId, secretKey);
        // 设置bucket的区域, COS地域的简称请参照 https://www.qcloud.com/document/product/436/6224
        ClientConfig clientConfig = new ClientConfig(new Region(region));
        // 生成cos客户端
        return new COSClient(cred, clientConfig);
    }
}
```

然后在 `manager` 包下创建可复用的 CosManager 类，专门负责和 COS 对象存储进行交互，提供文件上传功能，不包含特殊的业务逻辑。

```java
/**
 * COS对象存储管理器
 *
 * @author yupi
 */
@Component
@Slf4j
public class CosManager {

    @Resource
    private CosClientConfig cosClientConfig;

    @Resource
    private COSClient cosClient;

    /**
     * 上传对象
     *
     * @param key  唯一键
     * @param file 文件
     * @return 上传结果
     */
    public PutObjectResult putObject(String key, File file) {
        PutObjectRequest putObjectRequest = new PutObjectRequest(cosClientConfig.getBucket(), key, file);
        return cosClient.putObject(putObjectRequest);
    }

    /**
     * 上传文件到 COS 并返回访问 URL
     *
     * @param key  COS对象键（完整路径）
     * @param file 要上传的文件
     * @return 文件的访问URL，失败返回null
     */
    public String uploadFile(String key, File file) {
        // 上传文件
        PutObjectResult result = putObject(key, file);
        if (result != null) {
            // 构建访问URL
            String url = String.format("%s%s", cosClientConfig.getHost(), key);
            log.info("文件上传COS成功: {} -> {}", file.getName(), url);
            return url;
        } else {
            log.error("文件上传COS失败，返回结果为空");
            return null;
        }
    }
}
```

💡 不同规范下，Manager 层的作用可能不同。比如[《Alibaba Java开发手册》](https://www.codefather.cn/post/1607270508959641601)中的 Manager 层是指 **通用业务处理层**，它有如下特征：

1.  对第三方平台封装的层，预处理返回结果及转化异常信息（适配上层接口）
2.  对 Service 层通用能力的下沉，如缓存方案、中间件通用处理
3.  与 DAO 层交互，对多个 DAO 的组合复用

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Z0bskWiRi6xT40bK.webp)

#### 3、截图服务

考虑到后续项目要改造为微服务，最好将截图功能单独封装为一个 **通用服务**，将本地生成截图和文件上传整合在一起。不包含 appId 等具体的业务参数，作用就是根据要截图的网址返回截图后的图片地址。

在 `service` 包下新建 ScreenshotService 和实现类，代码如下：

```java
@Service
@Slf4j
public class ScreenshotServiceImpl implements ScreenshotService {

    @Resource
    private CosManager cosManager;

    @Override
    public String generateAndUploadScreenshot(String webUrl) {
        ThrowUtils.throwIf(StrUtil.isBlank(webUrl), ErrorCode.PARAMS_ERROR, "网页URL不能为空");
        log.info("开始生成网页截图，URL: {}", webUrl);
        // 1. 生成本地截图
        String localScreenshotPath = WebScreenshotUtils.saveWebPageScreenshot(webUrl);
        ThrowUtils.throwIf(StrUtil.isBlank(localScreenshotPath), ErrorCode.OPERATION_ERROR, "本地截图生成失败");
        try {
            // 2. 上传到对象存储
            String cosUrl = uploadScreenshotToCos(localScreenshotPath);
            ThrowUtils.throwIf(StrUtil.isBlank(cosUrl), ErrorCode.OPERATION_ERROR, "截图上传对象存储失败");
            log.info("网页截图生成并上传成功: {} -> {}", webUrl, cosUrl);
            return cosUrl;
        } finally {
            // 3. 清理本地文件
            cleanupLocalFile(localScreenshotPath);
        }
    }

    /**
     * 上传截图到对象存储
     *
     * @param localScreenshotPath 本地截图路径
     * @return 对象存储访问URL，失败返回null
     */
    private String uploadScreenshotToCos(String localScreenshotPath) {
        if (StrUtil.isBlank(localScreenshotPath)) {
            return null;
        }
        File screenshotFile = new File(localScreenshotPath);
        if (!screenshotFile.exists()) {
            log.error("截图文件不存在: {}", localScreenshotPath);
            return null;
        }
        // 生成 COS 对象键
        String fileName = UUID.randomUUID().toString().substring(0, 8) + "_compressed.jpg";
        String cosKey = generateScreenshotKey(fileName);
        return cosManager.uploadFile(cosKey, screenshotFile);
    }

    /**
     * 生成截图的对象存储键
     * 格式：/screenshots/2025/07/31/filename.jpg
     */
    private String generateScreenshotKey(String fileName) {
        String datePath = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
        return String.format("/screenshots/%s/%s", datePath, fileName);
    }

    /**
     * 清理本地文件
     *
     * @param localFilePath 本地文件路径
     */
    private void cleanupLocalFile(String localFilePath) {
        File localFile = new File(localFilePath);
        if (localFile.exists()) {
            File parentDir = localFile.getParentFile();
            FileUtil.del(parentDir);
            log.info("本地截图文件已清理: {}", localFilePath);
        }
    }
}
```

注意，本地截图文件在上传到对象存储后立即清理，避免占用服务器磁盘空间。同时，COS 对象键按日期分层存储，便于后续管理和维护。而且我们只需对外暴露 `generateAndUploadScreenshot` 这一个方法就好，其他的都是内部方法。

#### 4、触发截图生成

最后，我们需要在应用部署完成后触发截图生成。在 `AppServiceImpl` 的 `deployApp` 方法中添加相关逻辑：

```java
// 10. 构建应用访问 URL
String appDeployUrl = String.format("%s/%s/", AppConstant.CODE_DEPLOY_HOST, deployKey);
// 11. 异步生成截图并更新应用封面
generateAppScreenshotAsync(appId, appDeployUrl);
return appDeployUrl;
```

由于截图生成是一个相对耗时的⁠操作，我们必须使用⁠异步方式处理，避免阻塞用户的部署流程：

```java
@Resource
private ScreenshotService screenshotService;

/**
 * 异步生成应用截图并更新封面
 *
 * @param appId  应用ID
 * @param appUrl 应用访问URL
 */
@Override
public void generateAppScreenshotAsync(Long appId, String appUrl) {
    // 使用虚拟线程异步执行
    Thread.startVirtualThread(() -> {
        // 调用截图服务生成截图并上传
        String screenshotUrl = screenshotService.generateAndUploadScreenshot(appUrl);
        // 更新应用封面字段
        App updateApp = new App();
        updateApp.setId(appId);
        updateApp.setCover(screenshotUrl);
        boolean updated = this.updateById(updateApp);
        ThrowUtils.throwIf(!updated, ErrorCode.OPERATION_ERROR, "更新应用封面字段失败");
    });
}
```

这里我们使用了 Java 21 的虚拟线程（Virtual Thread）特性，这是由 JVM 管理的轻量级线⁠程。它的创建成本极低（几乎无内存开销），且在执行 I/O 操作时会自动⁠让出 CPU 给其他虚拟线程，从而在同样的系统资源下支持百万级并发而不是传统平台线程的几千级并发。而且它的使用和传统 Java 线程几乎没有区别，非常适合处理这种 I/O 密集型的异步任务。

相关面试题：[什么是协程？Java 支持协程吗？](https://www.mianshiya.com/question/1780933294863446018)

### 测试

部署项目后，等待大约 10 ⁠秒钟，我们就能看到⁠应用的封面图已经自动生成：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/gEPBHnHA8IwPjnxD.webp)

### 扩展思路

#### 1、截图服务优化

目前在生成截图时，我们是通过⁠静态方法初始化了一⁠个全局共用的 WebDriver，来避免重复加载。

这其实是一种简化写法，单纯为了追求更⁠高的性能。但是在并发截图⁠的场景下，如果复用同一个 WebDriver，可能会导致截图了错误的页面。

```java
// 危险：多线程共享同一个driver
private static final WebDriver webDriver = new ChromeDriver();

// 线程A: driver.get("page1.html") -> 截图
// 线程B: driver.get("page2.html") -> 截图  
// 结果：线程 A 可能截到 page2 的内容
```

有几种优化思路，大家可自行扩展：

1）每次创建新实例：

```java
public static String saveWebPageScreenshot(String webUrl) {
    WebDriver driver = initChromeDriver(); // 每次新建
    try {
        driver.get(webUrl);
        return takeScreenshot(driver);
    } finally {
        driver.quit(); // 用完就关闭
    }
}
```

优点是好理解，缺点是重复初始化驱动⁠会严重影响性能，不⁠推荐。                                

2）连接池模式，维护一个 W⁠ebDriver ⁠池，按需分配和回收。

```java
@Component
public class WebDriverPool {
    private final Queue<WebDriver> pool = new ConcurrentLinkedQueue<>();
    
    public WebDriver borrowDriver() { /* 获取空闲driver */ }
    public void returnDriver(WebDriver driver) { /* 归还driver */ }
}
```

优点是更灵活地复用线程，缺点⁠是实现成本较大，而⁠且需要额外维护池。

3）ThreadLocal ⁠模式，每个线程使用⁠同一个 WebDriver：

```java
private static final ThreadLocal<WebDriver> driverThreadLocal = new ThreadLocal<>();

public static WebDriver getDriver() {
    WebDriver driver = driverThreadLocal.get();
    if (driver == null) {
        driver = initChromeDriver();
        driverThreadLocal.set(driver);
    }
    return driver;
}
```

**比较推荐这种方案**，实现复杂度一般，而且能解决并发问题；缺点是如果你的线程数较多，webDriver 也较多、一直不释放，可能会导致内存溢出。

4）使用队列。将要执行的截图任⁠务依次放到队列中，W⁠ebDriver 线程组依次取出任务执行，本质是并行变串行。

一种比较简单的实现：

-   用 newSingleThreadExecutor() 确保只有一个处理线程，让所有截图任务串行执行
-   用 CompletableFuture 提交任务，自动处理任务队列和异步返回

```java
@Component
public class ScreenshotManager {
    private static final WebDriver webDriver = initChromeDriver();
    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    
    public CompletableFuture<String> takeScreenshot(String url) {
        return CompletableFuture.supplyAsync(() -> {
            webDriver.get(url);
            return doScreenshot(webDriver);
        }, executor);
    }
}
```

优点是性能好，可以异步返回结果、不阻塞调用方；缺点是⁠实现复杂度较大。不过如果并发量和稳⁠定性要求很高，用消息队列（比如 RabbitMQ 或 Kafka）也是合理的，也可以写在简历上。

编程导航的智能 BI 和 O⁠J 判题项目中都给⁠大家讲过消息队列，可以去学习下。

#### 2、功能优化

封面图功能还有很多优化空间：

1）在生成浏览网站时也可以调用封面生成，让⁠用户能够立即看到预览效果。我⁠们还可以设置定时任务自动检查数据库中没有封面的应用并生成封面，确保所有应用都有预览图。

2）为了提升用户体验，可以给每⁠个应用设置一个默认封⁠面地址，前端可以做降级逻辑，当封面生成失败或加载失败时显示默认图片。

3）在资源管理方面，需要定期⁠清理本地临时生成的⁠封面文件，以及在应用删除时关联删除对应的封面图，避免资源浪费。

比如可以用 Spring S⁠cheduler ⁠添加一个定时任务：

```java
@Configuration
@EnableScheduling
@Slf4j
public class ScreenshotConfig {

    /**
     * 每天凌晨2点清理过期的临时截图文件
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void cleanupTempScreenshots() {
        log.info("开始定时清理过期的临时截图文件");
        try {
            WebScreenshotUtils.cleanupTempFiles();
            log.info("定时清理临时截图文件完成");
        } catch (Exception e) {
            log.error("定时清理临时截图文件失败", e);
        }
    }
}
```

## 二、下载代码

### 需求分析

除了在线预览和使用生成的应用，用户可⁠能需要下载代码到本地进行二次⁠开发。这样一来，我们的平台不仅是一个在线工具，更是一个真正的开发起点。

大厂平台也是有这个能力的，下⁠载的内容是一个包含⁠所有代码文件的压缩包。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Igtz2iqKBB2VsdMT.png)

### 方案设计

实现代码下载功能需要考虑几个关键步骤：

1.  基础校验：我们需要验证应用是否存在、用户是否有下载权限等。考虑到安全性，只有应用的创建者才能下载对应的代码。
2.  找到应用的生成目录。这里要特别注意，我们要下载的是 **原始的生成目录**，而不是部署目录。部署目录是打包构建之后的文件，而生成目录包含的是源代码。
3.  定义文件过滤器，因为并不是所有文件都需要提供给用户下载。比如 `node_modules` 目录体积庞大且可以通过 `npm install` 重新安装，`dist` 和 `build` 目录是构建产物可以重新生成，`.DS_Store`、`.env` 等文件包含系统信息或敏感配置不应该下载。
4.  最后将过滤后的文件打包成 ZIP 压缩包，通过 HTTP 响应直接返回给前端。需要设置正确的响应头，告诉浏览器这是一个需要下载的文件、并且传递下载的文件名称。

### 后端开发

和截图服务类似，我们将项目下载单独封装为一个 `service` 包下的通用服务 `ProjectDownloadService`，可以对指定路径下的文件进行打包下载。

可以使用 Hutool 工具库的 `ZipUtil` 实现 ZIP 包压缩，支持指定文件过滤器，正好满足我们的需求。

1）实现文件过滤

这里有个小设计，我们不仅要过滤特定的⁠文件和目录名称，还过滤了⁠特定的文件扩展名。过滤逻辑会检查路径中的每一部分，确保不会遗漏无用文件。

```java
@Service
@Slf4j
public class ProjectDownloadServiceImpl implements ProjectDownloadService {

    /**
     * 需要过滤的文件和目录名称
     */
    private static final Set<String> IGNORED_NAMES = Set.of(
            "node_modules",
            ".git",
            "dist",
            "build",
            ".DS_Store",
            ".env",
            "target",
            ".mvn",
            ".idea",
            ".vscode"
    );

    /**
     * 需要过滤的文件扩展名
     */
    private static final Set<String> IGNORED_EXTENSIONS = Set.of(
            ".log",
            ".tmp",
            ".cache"
    );

    /**
     * 检查路径是否允许包含在压缩包中
     *
     * @param projectRoot 项目根目录
     * @param fullPath    完整路径
     * @return 是否允许
     */
    private boolean isPathAllowed(Path projectRoot, Path fullPath) {
        // 获取相对路径
        Path relativePath = projectRoot.relativize(fullPath);
        // 检查路径中的每一部分
        for (Path part : relativePath) {
            String partName = part.toString();
            // 检查是否在忽略名称列表中
            if (IGNORED_NAMES.contains(partName)) {
                return false;
            }
            // 检查文件扩展名
            if (IGNORED_EXTENSIONS.stream().anyMatch(partName::endsWith)) {
                return false;
            }
        }
        return true;
    }
}
```

2）下载压缩包核心方法：

```java
@Override
public void downloadProjectAsZip(String projectPath, String downloadFileName, HttpServletResponse response) {
    // 基础校验
    ThrowUtils.throwIf(StrUtil.isBlank(projectPath), ErrorCode.PARAMS_ERROR, "项目路径不能为空");
    ThrowUtils.throwIf(StrUtil.isBlank(downloadFileName), ErrorCode.PARAMS_ERROR, "下载文件名不能为空");
    File projectDir = new File(projectPath);
    ThrowUtils.throwIf(!projectDir.exists(), ErrorCode.NOT_FOUND_ERROR, "项目目录不存在");
    ThrowUtils.throwIf(!projectDir.isDirectory(), ErrorCode.PARAMS_ERROR, "指定路径不是目录");
    log.info("开始打包下载项目: {} -> {}.zip", projectPath, downloadFileName);
    // 设置 HTTP 响应头
    response.setStatus(HttpServletResponse.SC_OK);
    response.setContentType("application/zip");
    response.addHeader("Content-Disposition",
            String.format("attachment; filename=\"%s.zip\"", downloadFileName));
    // 定义文件过滤器
    FileFilter filter = file -> isPathAllowed(projectDir.toPath(), file.toPath());
    try {
        // 使用 Hutool 的 ZipUtil 直接将过滤后的目录压缩到响应输出流
        ZipUtil.zip(response.getOutputStream(), StandardCharsets.UTF_8, false, filter, projectDir);
        log.info("项目打包下载完成: {}", downloadFileName);
    } catch (Exception e) {
        log.error("项目打包下载异常", e);
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "项目打包下载失败");
    }
}
```

3）接下来在 `AppController` 中编写接口，拼接好应用代码目录和下载文件名，然后调用下载服务：

```java
@Resource
private ProjectDownloadService projectDownloadService;

/**
 * 下载应用代码
 *
 * @param appId    应用ID
 * @param request  请求
 * @param response 响应
 */
@GetMapping("/download/{appId}")
public void downloadAppCode(@PathVariable Long appId,
                            HttpServletRequest request,
                            HttpServletResponse response) {
    // 1. 基础校验
    ThrowUtils.throwIf(appId == null || appId <= 0, ErrorCode.PARAMS_ERROR, "应用ID无效");
    // 2. 查询应用信息
    App app = appService.getById(appId);
    ThrowUtils.throwIf(app == null, ErrorCode.NOT_FOUND_ERROR, "应用不存在");
    // 3. 权限校验：只有应用创建者可以下载代码
    User loginUser = userService.getLoginUser(request);
    if (!app.getUserId().equals(loginUser.getId())) {
        throw new BusinessException(ErrorCode.NO_AUTH_ERROR, "无权限下载该应用代码");
    }
    // 4. 构建应用代码目录路径（生成目录，非部署目录）
    String codeGenType = app.getCodeGenType();
    String sourceDirName = codeGenType + "_" + appId;
    String sourceDirPath = AppConstant.CODE_OUTPUT_ROOT_DIR + File.separator + sourceDirName;
    // 5. 检查代码目录是否存在
    File sourceDir = new File(sourceDirPath);
    ThrowUtils.throwIf(!sourceDir.exists() || !sourceDir.isDirectory(),
            ErrorCode.NOT_FOUND_ERROR, "应用代码不存在，请先生成代码");
    // 6. 生成下载文件名（不建议添加中文内容）
    String downloadFileName = String.valueOf(appId);
    // 7. 调用通用下载服务
    projectDownloadService.downloadProjectAsZip(sourceDirPath, downloadFileName, response);
}
```

注意，下载文件名最好是英文的，否则前端可能不会获取到。

### 前端开发 - Vibe Coding

后端开发完成后，记得先执行 `openapi` 命令，根据接口生成前端请求和数据模型代码。

前端实现下载功能的关键在于正确处理⁠ HTTP 响应，所以⁠我们在利用 AI 编程时，提示词中一定要包含接口 HTTP 响应的信息。

提示词如下：

```markdown
你是一位专业的前端开发，帮我根据下列信息，参考项目已有的代码风格，生成符合要求的完整代码。

## 需求

实现下载应用代码功能。在应用对话页面的部署按钮左侧增加 “下载代码” 按钮，点击后调用后端接口下载 ZIP 包。

需要注意不要修改 @api 目录下的任何文件，发送请求时适配接口返回的 HTTP 响应头信息：

// 设置 HTTP 响应头
response.setStatus(HttpServletResponse.SC_OK);
response.setContentType("application/zip");
response.addHeader("Content-Disposition",
        String.format("attachment; filename=\"%s.zip\"", downloadFileName));

## 后端接口

已经在 @api/ 目录下生成了后端请求代码和数据类型信息。
```

AI 改动的代码比较简单，首⁠先是在应用详情按钮⁠右侧补充了一个下载按钮：

```html
<a-button
  type="primary"
  ghost
  @click="downloadCode"
  :loading="downloading"
  :disabled="!isOwner"
>
  <template #icon>
    <DownloadOutlined />
  </template>
  下载代码
</a-button>
```

然后提供了调用后端下载代码的函数。由于后端直接返回文件流，我们需要使用原生的 `fetch` API 来获取响应，然后从响应头中提取文件名：

```javascript
// 下载相关
const downloading = ref(false)

// 下载代码
const downloadCode = async () => {
  if (!appId.value) {
    message.error('应用ID不存在')
    return
  }
  downloading.value = true
  try {
    const API_BASE_URL = request.defaults.baseURL || ''
    const url = `${API_BASE_URL}/app/download/${appId.value}`
    const response = await fetch(url, {
      method: 'GET',
      credentials: 'include',
    })
    if (!response.ok) {
      throw new Error(`下载失败: ${response.status}`)
    }
    // 获取文件名
    const contentDisposition = response.headers.get('Content-Disposition')
    const fileName = contentDisposition?.match(/filename="(.+)"/)?.[1] || `app-${appId.value}.zip`
    // 下载文件
    const blob = await response.blob()
    const downloadUrl = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = downloadUrl
    link.download = fileName
    link.click()
    // 清理
    URL.revokeObjectURL(downloadUrl)
    message.success('代码下载成功')
  } catch (error) {
    console.error('下载失败：', error)
    message.error('下载失败，请重试')
  } finally {
    downloading.value = false
  }
}
```

这段代码的核心是创建一个临时的下载链接。我们将响应的二进制数据转换为 Blob 对象，然后创建一个对象 URL，最后通过模拟点击 `<a>` 标签来触发下载。下载完成后记得调用 `URL.revokeObjectURL()` 释放内存。

效果如图，点击下载按钮后能够成功下载代码压缩包：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/sLteMIRUfwROtTQZ.webp)

![](https://pic.code-nav.cn/course_picture/1608440217629360130/r7taFFfZmEtpzw2R.png)

可以看到后端接口正确设置了响应头：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/AINgYfHfmBohOk4n.webp)

### 扩展思路

1）判断应用是否已经生成了浏⁠览地址，只有生成了⁠地址的应用才允许下载（需要后端配合修改逻辑）。

2）添加下载统计功能，记录每个⁠应用的下载次数，有助⁠于了解用户行为和优化系统，比如利用 CDN 对热门应用进行加速。

## 三、AI 智能选择方案

### 需求分析

目前我们平台提供了 3 套不同的代码生成⁠方案：原生 HTML、原生⁠多文件、Vue 工程。分别适合不同复杂度的项目需求，也使用了成本不同的大模型。

那么问题来了，当用户提出需求⁠时，如何判断应该使⁠用哪套方案呢？

让用户自己选择的话，会增加用户的使用门槛。更好的方案是让 AI 来自动判断，这就是所谓的 **智能路由**。

![image.png](https://pic.code-nav.cn/course_picture/1608440217629360130/5862Jm82YJYke6Qd.webp)

### 方案设计

在实际生产环境中，智能路由本身应该选择 **成本更低、输出更快** 的大模型，因为路由决策是一个相对简单的分类任务，不需要太强的模型。

官方也专门提出了 [利用 AI 进行分类的文档](https://docs.langchain4j.dev/tutorials/classification)。

我们可以利用 LangChai⁠n4j 的结构化输出⁠功能来实现智能路由。结构化输出支持枚举类型，这正好符合我们的需求：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/zFmeayuD3CAFczkl.webp)

编写一段用于 AI 路由的提示词，需要给出清晰的判断规则：

```markdown
你是一个专业的代码生成方案路由器，需要根据用户需求返回最合适的代码生成类型。

可选的代码生成类型：
1. HTML - 适合简单的静态页面，单个 HTML 文件，包含内联 CSS 和 JS
2. MULTI_FILE - 适合简单的多文件静态页面，分离 HTML、CSS、JS 代码
3. VUE_PROJECT - 适合复杂的现代化前端项目

判断规则：
- 如果用户需求简单，只需要一个展示页面，选择 HTML
- 如果用户需要多个页面但不涉及复杂交互，选择 MULTI_FILE
- 如果用户需求复杂，涉及多页面、复杂交互、数据管理等，选择 VUE_PROJECT
```

### 后端开发

首先将提示词保存到 `resources/prompt/codegen-routing-system-prompt.txt` 文件中。

为了快速验证功能，我们先复用之前自动注入的 `chatModel`，跑通整个业务流程。

1）在 `ai` 包下新建 AI 智能路由服务，也是一个 AI Service：

```java
/**
 * AI代码生成类型智能路由服务
 * 使用结构化输出直接返回枚举类型
 *
 * @author yupi
 */
public interface AiCodeGenTypeRoutingService {

    /**
     * 根据用户需求智能选择代码生成类型
     *
     * @param userPrompt 用户输入的需求描述
     * @return 推荐的代码生成类型
     */
    @SystemMessage(fromResource = "prompt/codegen-routing-system-prompt.txt")
    CodeGenTypeEnum routeCodeGenType(String userPrompt);
}
```

注意方法的返回值是枚举类型，框⁠架帮我们实现结构化⁠输出。                                

2）创建 AI 智能路由服务工厂：

```java
/**
 * AI代码生成类型路由服务工厂
 *
 * @author yupi
 */
@Slf4j
@Configuration
public class AiCodeGenTypeRoutingServiceFactory {

    @Resource
    private ChatModel chatModel;

    /**
     * 创建AI代码生成类型路由服务实例
     */
    @Bean
    public AiCodeGenTypeRoutingService aiCodeGenTypeRoutingService() {
        return AiServices.builder(AiCodeGenTypeRoutingService.class)
                .chatModel(chatModel)
                .build();
    }
}
```

3）将创建应用的逻辑从 Contr⁠oller 提取到 S⁠ervice 中（因为这个方法有更多业务逻辑了），并集成智能路由服务：

```java
@Resource
private AiCodeGenTypeRoutingService aiCodeGenTypeRoutingService;

@Override
public Long createApp(AppAddRequest appAddRequest, User loginUser) {
    // 参数校验
    String initPrompt = appAddRequest.getInitPrompt();
    ThrowUtils.throwIf(StrUtil.isBlank(initPrompt), ErrorCode.PARAMS_ERROR, "初始化 prompt 不能为空");
    // 构造入库对象
    App app = new App();
    BeanUtil.copyProperties(appAddRequest, app);
    app.setUserId(loginUser.getId());
    // 应用名称暂时为 initPrompt 前 12 位
    app.setAppName(initPrompt.substring(0, Math.min(initPrompt.length(), 12)));
    // 使用 AI 智能选择代码生成类型
    CodeGenTypeEnum selectedCodeGenType = aiCodeGenTypeRoutingService.routeCodeGenType(initPrompt);
    app.setCodeGenType(selectedCodeGenType.getValue());
    // 插入数据库
    boolean result = this.save(app);
    ThrowUtils.throwIf(!result, ErrorCode.OPERATION_ERROR);
    log.info("应用创建成功，ID: {}, 类型: {}", app.getId(), selectedCodeGenType.getValue());
    return app.getId();
}
```

这样，应用创建时会自动调用智⁠能路由服务，根据用⁠户的初始提示词选择最合适的代码生成类型。

4）相应地，AppController 的代码可以简化：

```java
@PostMapping("/add")
public BaseResponse<Long> addApp(@RequestBody AppAddRequest appAddRequest, HttpServletRequest request) {
    ThrowUtils.throwIf(appAddRequest == null, ErrorCode.PARAMS_ERROR);
    // 获取当前登录用户
    User loginUser = userService.getLoginUser(request);
    Long appId = appService.createApp(appAddRequest, loginUser);
    return ResultUtils.success(appId);
}
```

5）最后，编写一个单元测试来验证智能路由的效果：

```java
@Slf4j
@SpringBootTest
public class AiCodeGenTypeRoutingServiceTest {

    @Resource
    private AiCodeGenTypeRoutingService aiCodeGenTypeRoutingService;

    @Test
    public void testRouteCodeGenType() {
        String userPrompt = "做一个简单的个人介绍页面";
        CodeGenTypeEnum result = aiCodeGenTypeRoutingService.routeCodeGenType(userPrompt);
        log.info("用户需求: {} -> {}", userPrompt, result.getValue());
        userPrompt = "做一个公司官网，需要首页、关于我们、联系我们三个页面";
        result = aiCodeGenTypeRoutingService.routeCodeGenType(userPrompt);
        log.info("用户需求: {} -> {}", userPrompt, result.getValue());
        userPrompt = "做一个电商管理系统，包含用户管理、商品管理、订单管理，需要路由和状态管理";
        result = aiCodeGenTypeRoutingService.routeCodeGenType(userPrompt);
        log.info("用户需求: {} -> {}", userPrompt, result.getValue());
    }
}
```

这个测试覆盖了 3 种不同复⁠杂度的需求，可以验⁠证智能路由是否能够正确分类。

需要注意的是，由于我们返回的是简单的⁠枚举类型而不是复杂的 J⁠SON 对象，需要在配置文件中注释掉模型的 JSON 约束，否则可能会报错：

```yaml
langchain4j:
  open-ai:
    chat-model:
#      strict-json-schema: true
#      response-format: json_object
```

![](https://pic.code-nav.cn/course_picture/1608440217629360130/drHuDwY4KUZ14fd6.webp "null")

改完配置后，从日志中可以看到结构化输出修改了提示词：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/bu0siF75GYF2XYOc.webp "null")

测试结果符合预期，AI 能够⁠根据需求复杂度选择⁠合适的生成方案：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/e5BpubP6YyUnsmw5.webp "null")

### 前端开发 - Vibe Coding

为了让用户了解系统选择的生成类型，⁠我们需要在前端展示这个⁠信息。可以在应用详情页的标题右侧和应用详情弹窗内增加生成类型的标签展示。

发给 AI 的提示词：

```markdown
在应用详情页给应用增加生成类型的展示，增加位置：
- 标题右侧
- 应用详情弹窗内
```

AI 修改了 AppChat⁠Page，应用标题⁠右侧增加了生成类型标签：

```html
<!-- 顶部栏 -->
<div class="header-bar">
  <div class="header-left">
    <h1 class="app-name">{{ appInfo?.appName || '网站生成器' }}</h1>
    <a-tag v-if="appInfo?.codeGenType" color="blue" class="code-gen-type-tag">
      {{ formatCodeGenType(appInfo.codeGenType) }}
    </a-tag>
  </div>
```

并添加了对应的样式：

```css
.code-gen-type-tag {
  font-size: 12px;
}
```

AI 还修改了 AppDet⁠ailModal ⁠弹窗组件，在应用创建时间下新增了类型信息：

```html
<div class="info-item">
  <span class="info-label">生成类型：</span>
  <a-tag v-if="app?.codeGenType" color="blue">
    {{ formatCodeGenType(app.codeGenType) }}
  </a-tag>
  <span v-else>未知类型</span>
</div>
```

效果如图，对话页面：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/UimP8ZNFtW21eQyo.webp)

在应用详情弹窗中也会显示生成类型：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/5wyCukbVUFtFF1Ri.webp)

让我们验证一下智能路由的实际效果，创建不同复杂度的应用：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/vPkKHnRxr1n61S6Q.webp)

![](https://pic.code-nav.cn/course_picture/1608440217629360130/RHZQYWHMCNuxz0o6.webp)

![](https://pic.code-nav.cn/course_picture/1608440217629360130/7jmvXsbjbIoWZCRC.webp)

可以看到，智能路由准确地为不同复杂度的需求选择了合适的生成方案。简单的个人介绍页面选择了 HTML 方案，公司官网选择了 MULTI\_FILE 方案，精美的多模块作品展示网选择了 VUE\_PROJECT 方案。

### 扩展思路

大家可以思考一下，目前我们的⁠ AI 智能路由方⁠案还有什么可以优化的地方么？后续教程会给出答案。


