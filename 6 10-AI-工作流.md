---
source: https://www.codefather.cn/course/1948291549923344386/section/1955468615553167362
---

# 10 - AI 工作流 - 【大厂必备】LangChain4j +

> ## Excerpt
> 本节重点 本节我们将为 AI 零代码应用生成平台引入一个全新的技术架构 —— AI 智能体工作流，通过 LangGraph4j 框架重构代码生成逻辑，并补充搜集图片素材、代码质量检查等过程。编程导航教程分享，做您编程学习路上的导航员。

---
## 本节重点

本节我们将为 AI 零代码应用生成平台引入一个全新的技术架⁠构 —— AI 智能体工作流，通过 L⁠angGraph4j 框架重构代码生成逻辑，并补充搜集图片素材、代码质量检查等过程，让生成的网站更真实可靠。

本节主要内容如下：

-   工作流方案选型
-   LangGraph4j 入门
-   核心工作流开发
-   LangGraph4j 工作流特性实战

鱼皮对本节教程精心设计，想要⁠快速学习 AI 工⁠作流技术的同学，可以单独学习本章内容。

## 一、需求分析

目前生成的网站内的图片都是随⁠机占位图片，实际上⁠可以根据网站类型补充素材图片，让生成的网站更真实。

___

如果想快速实现这个需求，其实只⁠需要提供给 AI 图⁠片搜索工具就好，交给框架和 AI 来决定什么时候调用工具，自动执行。

但是，之前鱼皮也提到了，对于可标准化的工作流程（搜集图片是在生成网站前的固定步骤），**能标准化的建议标准化**，不要交给 AI 来自主判断，这样可以减少随机性和误差，而且还可以自主对流程进行新增、编排和优化。

因此，接下来鱼皮会带大家学习⁠一套新的网站生成方⁠案 —— 基于工作流来实现。

💡 注意，跟之前已有的 3⁠ 种生成模式不同，⁠本节我们不是在开发一种新的生成模式，而是一套新的系统实现方式。

原本我们是把各个流程自己分散到了 Service⁠ 等类的各个方法，比如获取代码生⁠成类型、调用 AI 流式输出、保存文件、打包构建等。而现在，我们需要把这一套流程用工作流组合起来。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/l1T0yRQlUs0ctxwW.webp "null")

因此，本节我们不改变原有的任何业务流程。只新增⁠一种实现，重点是让大家学习到工⁠作流的思想和实现方式。这样一来，本节内容能够作为可选项独立学习，不影响之前已完成的项目。

## 二、工作流方案选型

为了实现 AI 工作流，我们可以考虑市面上很多现成的平台，⁠像 Dify、Coze、阿里云百炼，通⁠过拖拽式的界面就能快速搭建工作流，上手简单、能够快速看到效果，非常适合快速验证想法或者让非技术人员参与构建流程。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/QkvuabwkqsasZQF0.webp)

但是，当涉及到复杂的业务逻辑时，“⁠低代码平台” 可能无法⁠满足我们的定制化需求，尤其是当系统需要与现有的业务逻辑深度集成时。

相比之下，LangGraph4j 这样的工作流编程框架虽然需要一定的学习成本，但它⁠提供了完全的控制能力。对于我们这个项目来说，既要与现有⁠的 Spring Boot 系统深度集成，又要处理图片收集、AI 代码生成、质量检查等复杂的业务逻辑，选择 LangGraph4j 会更加合适。

当然，更重要的是，LangGraph4j 作为一个专门为 Java 生态设计的工作流框架，**和 LangChain4j 兼容性很好**，能够无缝融入我们现有的技术栈，可以直接复用项目中已有的 Service、配置和工具类，不需要从 0 进行开发。同时，它还提供了丰富的高级特性，比如条件边、循环执行、并发处理等，让我们能够构建出智能化的工作流程。

从长远来看，选择编程框架而不是别人的低代码工作流平台，还有⁠一个重要优势：可维护性和扩展性。随着业⁠务的发展，我们的工作流可能会变得越来越复杂，编程框架能够更好地支持这种迭代，而不会像低代码平台那样遇到天花板。

## 三、LangGraph4j 入门

[LangGraph4j](https://langgraph4j.github.io/langgraph4j/) 是一个 Java 实现的开源 AI 工作流框架，它受到了 Python 版本 LangGraph 的启发，能够与 Langchain4j 和 Spring AI 无缝集成，而且这个框架还是 [开源](https://github.com/langgraph4j/langgraph4j) 的。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/SsPHNdXHTQcu5Zl3.webp)

美中不足的是，目前这个框架还处于 “不成熟期”⁠，虽然已经能够满足大多数工作流⁠开发的需求了，但是功能上还不够完善，文档写的也有点敷衍了，可能还有一些出其不意的小 Bug。

不过好在鱼皮帮大家踩了一遍坑，我的建议是大家 **严格遵循本教程中的版本号**，收起你那好奇心，**不要用和鱼皮不一致的版本、也先不要自己探索**，把工作流的开发思路学会就足够了。后面框架肯定会持续更新的，你的能力上来后对着官方文档去了解新的变动就好。

根据 [官方特性文档](https://langgraph4j.github.io/langgraph4j/features/)，LangGraph4j 提供了以下核心能力，我们依次来学习。

### 核心特性

#### StateGraph 工作流图

在 LangGraph4j ⁠中，StateGr⁠aph 是主要使用的核心类，用于定义应用程序的结构。

它将复杂的 AI 工作流抽象为一个 **有向图** 的概念。每个 **节点** 代表一个具体的操作单元，比如调用 LLM 生成文本、搜索外部数据、处理用户输入等。节点之间通过 **边** 来连接，多个节点之间通过 **状态** 来共享数据，形成了一个完整的处理流程。

和传统的有向无环图（DAG）不同，LangGra⁠ph4j 支持循环，比如一个智能⁠体可能需要根据结果回到之前的步骤进行重试，或者需要在某个条件满足之前持续循环执行某个逻辑。

注意，使用图之前必须编译，编译过程不仅会进行基础的结构检查（比如检查是否有孤立的节点），还会定义运行时参数，创建一个不可变的、可运行的图 `CompiledGraph<S extends AgentState>`。

#### AgentState 状态

AgentState 是整个工作流的状态载体，它本质上是一个 `Map`，在不同节点之间传递。**每个节点都可以从这个状态中读取数据，并返回对状态的更新。**

有一些和状态有关的概念，仅做了解即可：

1）Schema：状态的结构通过 Schema 来定义，这是一个 `Map<String, Channel.Reducer>` 的映射。Schema 中的每个键对应状态中的一个属性，而值则是一个 Channel.Reducer，用于定义如何处理对该属性的更新。（理解成数据库的表结构就好）

2）Channel.Reducer 是状态更新的核心机制，它定义了如何将新值与现有值进行合并。比如，一个新值可能会覆盖旧值，或者可能会被添加到现有值的列表中。

LangGraph4j 提供⁠了几种内置的 Re⁠ducer 类型：

-   Channel.Default 为状态属性提供默认值
-   Channel.Appender 会将新值追加到与状态属性关联的列表中，这对于累积消息、工具调用或其他数据序列特别有用
-   MessageChannel.Appender 专为聊天消息设计，不仅可以处理消息追加，还可以通过 ID 处理消息删除。

你可以根据具体的业务需求来定⁠义不同的 Redu⁠cer 策略，确保状态在整个工作流中正确地流转和更新。

💡 但实际应用中，如果不需要利用 LangGraph4j 的持久化机制，就不⁠是很建议大家用内置的 Schema 和 Reduce⁠r 来维护状态了。不如自己定义一个 Context 上下文类来管理状态，想怎么操作状态就怎么操作，不用理解 LangGraph4j 自己的一套语法。

#### Nodes 工作节点

节点是图的构建块，**负责执行具体的操作**。

一个节点通常是一个函数或一个实现了 `NodeAction<S>` 或 `AsyncNodeAction<S>` 接口的类，可以在其中编写具体的操作代码。

节点的工作流程很清晰：首先接收当前的 AgentState 状态作为输入，然后执行某些计算（比如调用 LLM、执行工具、运行自定义业务逻辑），最后返回一个 `Map<String, Object>`，表示对状态的更新。这些更新会根据 Schema 中定义的 Reducer 应用到 AgentState 中。

节点可以是同步的，也可以是异⁠步的，甚至可以多个⁠节点同时执行。

LangGraph4j 还定义了两个⁠特殊的节点：START ⁠和 END。START 节点表示图的入口点，END 节点表示执行路径的结束点。

```java
import static org.bsc.langgraph4j.StateGraph.START;
import static org.bsc.langgraph4j.StateGraph.END;

graph.addEdge(START, "nodeA");
graph.addEdge("nodeA", END);
```

这也是工作流的经典设计了，让⁠工作流的起始和结束⁠变得明确可控。

#### Edges 边

边定义了节点之间的控制流，决⁠定了工作流的执行⁠路径。正如官方文档所说：“节点负责干活，边负责决定下一步”。

LangGraph4j 支持几种不同类型的边：

-   普通边：最简单的边类型，提供从一个节点到另一个节点的无条件转换。可以通过 `addEdge(sourceNodeName, destinationNodeName)` 来定义普通边。
-   条件边：下一个节点是根据当前 AgentState 动态确定的，更加灵活。当源节点完成后，会执行一个判断函数，这个函数接收当前状态并返回下一个要执行的节点名称。相当于实现了 if else 分支逻辑。比如智能体决定使用工具，就跳转到 “执行工具” 节点，否则跳转到 “回复用户” 节点。
-   入口点：可以定义当用户输入到达时首先调用哪个节点，同样支持条件入口点。

通过普通边和条件边，就能组合⁠出各种工作流图，而⁠入口点一般没必要使用。

#### Checkpoints 检查点

检查点允许你保存图在任何步骤⁠的状态，也就是状态⁠的持久化，有利于调试和恢复复杂的工作流。

检查点的核心作用主要体现在两个方面：

1）支持人类检查、中断和批准工作步骤。在某些场景下，人类必须能够在任何时间点查看图⁠的状态，并且图必须能够在人类对状态进行任何更新后恢复⁠执行。这种 “人在环路”（human-in-the-loop）的设计在许多实际应用中都是必需的，比如 Cursor 在使用文件删除工具时会找用户确认。

2）允许通过线程隔离不同用户的交互，并且相同用户可以恢复之前的记忆。这对⁠于构建多用户的 AI 应用来说特别重要，每个用户⁠都可以有自己独立的执行历史。跟我们之前学习的 Chat Memory 对话记忆类似，给工作流传入不同的 thread\_id 配置即可：

```java
var config = RunnableConfig.builder()
                  .threadId("a")
                  .build();
graph.invoke(inputs, config);
```

LangGraph4j 默认提供了基于内存的检查点器：

```java
var saver = new MemorySaver();
```

在实际使用中，要根据具体需求来选择合适的持久化方案。内存检查点器适合开发和测试，但对于生产环境，需要考虑更持久的存储方案，比如 [保存到 Postgre SQL](https://langgraph4j.github.io/langgraph4j/core/checkpoint-postgres/)。

### Demo

了解核心特性后，我们 [参考官方文档](https://langgraph4j.github.io/langgraph4j/getting-started/#your-first-graph-a-simple-example) 来运行一个工作流 Demo —— `SimpleGraphApp`，把所有代码都放到 `langgraph4j.demo` 包下。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/aQJBBQIWajD8aNKn.webp)

注意，使用以下版本的依赖：

```xml
<!-- LangGraph4j -->
<dependency>
    <groupId>org.bsc.langgraph4j</groupId>
    <artifactId>langgraph4j-core</artifactId>
    <version>1.6.0-rc2</version>
</dependency>
```

### 高级特性

下面再分享一些 LangGr⁠aph4j 的高级⁠特性，先仅做了解即可，很多特性我们都会在本项目中实战。

#### Streaming 异步和流式处理

首先，通过 CompletableFuture，La⁠ngGraph4j 允许非阻塞的异步⁠操作。也就是说，当某个节点在等待 LLM 响应时，整个应用不会被阻塞，可以继续处理其他任务。

根据 [流式处理文档](https://langgraph4j.github.io/langgraph4j/core/streaming/)，LangGraph4j 支持通过 Java 异步生成器来处理来自 LLM 和其他源的流式响应，可以实现 SSE 流式输出，提升用户体验。

此外，流式处理不仅支持主流的输出，还能处理⁠子流，并且在所有流输出完成后⁠获取到最终结果。跟之前 LangChain4j 的 TokenStream 类似。

#### 可视化

LangGraph4j 通过 `graph.getGraph` 方法提供了多种内置的工作流可视化方式。可以选择使用 [PlantUML](https://plantuml.com/) 或者 [Mermaid](https://mermaid.js.org/) 文本绘图语法来生成工作流的结构图，帮助我们理解复杂工作流的结构。

就像这样：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/cGIKThxXX5x372i3.webp)

#### Parallel Branch 并发

LangGraph4j 提供了 [并发特性](https://langgraph4j.github.io/langgraph4j/core/parallel-branch/)，能够同时执行多个工作节点或分支，从而提升整体性能。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/8r27gkXstNw3nluZ.png)

但是目前并发处理存在一些限制⁠，比如不支持条件边⁠、并且并发执行的分支中只能有一个工作节点。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/NcShyrThIeq6vuyM.webp)

对于复杂的并发场景，可以通过子图特性来解决这些限制。

#### Subgraphs 子图

如果一个工作流图特别复杂，或者其中的一些流程需要复用，就可以考虑 [子图功能](https://langgraph4j.github.io/langgraph4j/core/subgraph/)。相当于把一个工作流拆分成多个子模块，而且多个子图可以同时并发执行。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/0Yw25cCuH3aEmiML.webp)

有 3 种不同的使用方式，适合不同的场景。

1）直接添加：这种方式会将子图完全⁠合并到父图中，无缝⁠集成。在这种模式下，父图和子图共享所有状态，子图就像是父图的一个扩展部分。

```java
stateGraph.addNode("subgraph", workflowChild)
```

2）编译添加：这种方式让子图和⁠父图保持一定的独立性⁠，只共享部分状态。适合需要一定独立性但又需要与主流程交互的场景。

```java
stateGraph.addNode("subgraph", workflowChild.compile())
```

3）操作节点：可以自己定义子图⁠和父图之间的交互逻辑⁠，包括状态的转换、数据的传递等，最灵活。适合需要复杂交互逻辑的场景。

```java
StateGraph.addNode( "subgraph",  state -> {
    var input =  Map.<String,Object>of( "subgraphKey", state.lastMessage().orElseThrow() );
    return compiledWorkflowChild.stream( input )
        .forEachAsync( System.out::println )
        .thenApply( ( res ) -> state.data() );
    });
```

子图功能不仅支持可视化（可以在⁠图表中看到子图的结构⁠），还支持流式处理。不过在操作节点方式下，你需要自己处理流的传递。

#### Breakpoints 断点

有时我们需要在某个关键节点暂停执行，等待人工审核或确认，LangGraph4j 的 [断点功能](https://langgraph4j.github.io/langgraph4j/core/low_level/#breakpoints) 正是为这种场景设计的。

断点可以在编译时静态指定，也可以通过让节⁠点操作实现特定接口来在运行⁠时动态设置。当图执行到设置了断点的节点时，它会自动暂停，等待外部信号才会继续执行。

```java
// 静态指定
var compileConfig = CompileConfig.builder()
                        .checkpointSaver(saver)
                        .interruptBefore( "tools")
                        .build();

// 动态设置
public interface InterruptableAction<State extends AgentState> {
   Optional<InterruptionMetadata<State>> interrupt(String nodeId, State state);
}
```

这个特性在实现 “人在环路” 的 AI 系统时⁠特别有用。比如在代码生成系统中⁠，可能希望在生成代码后暂停执行，让人工审核代码质量，确认无误后再继续后续的构建和部署流程。

需要注意的是，**使用断点功能时必须配合检查点器使用**。因为图需要能够保存当前状态并在稍后恢复执行。要恢复执行，只需要调用 `GraphInput.resume()` 即可。

### 工具

#### Studio 开发环境

[Studio](https://langgraph4j.github.io/langgraph4j/studio/) 是 LangGraph4j 提供的开发环境，它是一个 Web 界面，可以对 Langgraph4j 工作流进行可视化交互和调试。

通过 Studio，你可以实时观察工⁠作流的执行状态，查看每个⁠节点的输入输出，理解状态在不同节点之间的流转过程，有助于复杂工作流的开发调试。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/6lDCRedX19b9Yde5.webp)

Studio 支持和 Spri⁠ng Boot、Qu⁠arkus 和 Jetty 快速集成，本节后面我们也会实战。

#### Builder 构建工具

LangGraph4j 提供了一个 [可视化的工作流构建工具](https://github.com/langgraph4j/langgraph4j-builder)，可以通过拖拉拽的方式开发工作流，自动生成对应的 Java 代码。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/axagwaFCZbl1wTuj.webp)

这里鱼皮利用 [云托管平台](https://cloud.weixin.qq.com/cloudrun/service) 快速以容器的方式运行工具，先利用官方提供的容器镜像构建服务：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/pF0CmstWgmvKrRDz.webp "null")

需要正确设置环境变量：

```markdown
-e NODE_ENV=production \
-e LANGRAPH4J_GEN=generator-1.6-SNAPSHOT-jar-with-dependencies.jar
```

注意，不要按照作者文档中的设置 `-e RUNNING_IN_DOCKER=true`，可能导致无法生成代码！

![](https://pic.code-nav.cn/course_picture/1608440217629360130/VdxTkAH62VRXDn88.webp)

确保服务成功启动：     ⁠         ⁠                  

![](https://pic.code-nav.cn/course_picture/1608440217629360130/J1lDQt3MCdwRkX4y.webp)

第一次进入时，可以跟着网页的⁠提示学习用法，其实⁠就是画流程图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/56LHHCerWP1vLEkv.webp)

构建器预置了 2 个模板：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/MUqdDGdA9mmMpP2C.webp)

可以通过简单的拖拽操作来设计⁠工作流，然后自动生⁠成对应的 Java 代码，提高开发效率：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/JkZaz2BtIcbfaxca.webp)

生成的代码可以给我们作为参考：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/o9bDeBzryK0RKXBf.webp)

不过需要注意的是，对于包含循环的复杂工作流，生成的代码可能⁠不够准确，而且会包含一些冗余内容，所以⁠我个人不太喜欢用这个工具（目前也没多少人用），还不如用 AI 来根据我们描述好的流程图来生成工作流代码。

### 集成

LangGraph4j 可以快速和 Langchain4j / Spring AI 进行 [集成](https://langgraph4j.github.io/langgraph4j/integration/)。

比如通过 AgentExecuto⁠r，可以快速将 Cha⁠tModel 和 Tools 转换为 ReACT Agent 工作流：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/CD0Or9C6uQZMBFHO.png)

也就是说，当需要用到工作流时，我们不需要重新学⁠习全新的 AI 框架和 API⁠，而是在现有的 Langchain4j 或 Spring AI 基础上添加工作流的能力即可。

### 更多示例

LangGraph4j 提供了一些 [实用示例](https://langgraph4j.github.io/langgraph4j/how-tos/adaptiverag/)，不仅提供了代码参考，而且还可以做为不同场景下的最佳实践。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/gOMzibKWnZ6WNMut.webp)

其中我觉得自适应 RAG 系统⁠的示例是值得学习的，⁠它展示了如何根据用户描述智能选择搜索引擎和知识库来回答问题。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/C0UpmDgGvrcpFFxp.webp)

其他几个值得学习的例子，感兴趣的同学可自行学习：

-   [等待人工输入](https://langgraph4j.github.io/langgraph4j/how-tos/wait-user-input/)：演示了如何在工作流中实现人机交互，构建需要人工确认的 AI 系统时可以参考
-   [LangChain4j 流式输出集成](https://langgraph4j.github.io/langgraph4j/how-tos/llm-streaming/)：展示了如何处理实时的 AI 响应流。
-   [MCP 对接](https://github.com/langgraph4j/langgraph4j-examples/tree/main/langchain4j/mcp-client-agent)：在 LangGraph4j 中整合 MCP 服务
-   [管理模式的多智能体架构](https://langgraph4j.github.io/langgraph4j/how-tos/multi-agent-supervisor/)：使用 LLM 对智能体进行编排

![](https://pic.code-nav.cn/course_picture/1608440217629360130/iYhL1jEKL8ze4eje.webp)

## 四、核心工作流开发

了解了 LangGraph4⁠j 的特性后，下面⁠我们直接在项目中实战。

### 工作流开发步骤

工作流开发的核心是：节点 + 边 + 状态 + 其他特性

具体步骤：

1.  定义工作流结构（所有工作节点先只是临时输出、也无需记录状态）
2.  定义状态
3.  定义工作节点，先通过假数据模拟状态流转
4.  开发真实的工作节点
5.  工作流中使用节点，提供完整的工作流服务

### 定义工作流结构

根据我们的需求梳理出工作流程：

1.  输入原始 Prompt
    
2.  获取图片素材 Agent：通过工具调用从不同的渠道获取图片
    
3.  内容图片：pexels 网页搜索
    
4.  插画图片：undraw 抓取
    
5.  画架构图：文本绘图 + 上传到 COS
    
6.  Logo 等设计图片：AI 生成或者 MCP
    
7.  提示词增强：关联图片内容到原始提示词
    
8.  智能路由 Agent：选用哪种模式生成网站？
    
9.  原生 HTML
    
10.  原生多文件
    
11.  Vue 工程
    
12.  网站生成 Agent：利用搜集到的图片，根据上一步确认的生成模式来生成网站
    
13.  项目构建器：文件保存 / 打包构建
    

![](https://pic.code-nav.cn/course_picture/1608440217629360130/TXRVc36FSrQ6wZ4K.webp)

有了详细的工作流程描述后，可以利用 ⁠AI，根据 LangGr⁠aph4j 的官方文档和示例，快速生成基础的工作流结构代码，比如下列提示词：

```markdown
帮我生成 LangGraph4j 工作流的代码

## 工作流的流程描述

// ... 补充具体的流程

## 要求

先生成基础的工作流结构代码，每个工作节点中只输出一句信息就够了，不用真正实现具体的业务逻辑。

## 参考信息

官方文档：@https://langgraph4j.github.io/langgraph4j/core/low_level/
示例工作流实现：@https://github.com/langgraph4j/langgraph4j-examples/blob/main/langchain4j/adaptive-rag/src/main/java/dev/langchain4j/adaptiverag/AdaptiveRag.java
```

得到简化版的工作流结构代码如下，存放到 `langgraph4j` 包下：

```java
/**
 * 简化版网站生成工作流应用 - 使用 MessagesState
 */
@Slf4j
public class SimpleWorkflowApp {

    /**
     * 创建工作节点的通用方法
     */
    static AsyncNodeAction<MessagesState<String>> makeNode(String message) {
        return node_async(state -> {
            log.info("执行节点: {}", message);
            return Map.of("messages", message);
        });
    }

    public static void main(String[] args) throws GraphStateException {
        // 创建工作流图
        CompiledGraph<MessagesState<String>> workflow = new MessagesStateGraph<String>()
                // 添加节点
                .addNode("image_collector", makeNode("获取图片素材"))
                .addNode("prompt_enhancer", makeNode("增强提示词"))
                .addNode("router", makeNode("智能路由选择"))
                .addNode("code_generator", makeNode("网站代码生成"))
                .addNode("project_builder", makeNode("项目构建"))

                // 添加边
                .addEdge(START, "image_collector")                // 开始 -> 图片收集
                .addEdge("image_collector", "prompt_enhancer")    // 图片收集 -> 提示词增强
                .addEdge("prompt_enhancer", "router")             // 提示词增强 -> 智能路由
                .addEdge("router", "code_generator")              // 智能路由 -> 代码生成
                .addEdge("code_generator", "project_builder")     // 代码生成 -> 项目构建
                .addEdge("project_builder", END)                  // 项目构建 -> 结束

                // 编译工作流
                .compile();

        log.info("开始执行工作流");

        GraphRepresentation graph = workflow.getGraph(GraphRepresentation.Type.MERMAID);
        log.info("工作流图: \n{}", graph.content());

        // 执行工作流
        int stepCounter = 1;
        for (NodeOutput<MessagesState<String>> step : workflow.stream(Map.of())) {
            log.info("--- 第 {} 步完成 ---", stepCounter);
            log.info("步骤输出: {}", step);
            stepCounter++;
        }

        log.info("工作流执行完成！");
    }
}
```

上述代码的几个关键：

1.  使用了 LangGraph4j 内置的 `MessageState` 消息列表作为状态
2.  直接提供了一个创建节点的方法，每个工作节点都只是打印个日志，便于快速验证工作流结构
3.  通过可视化能力打印出工作流图的结构

执行工作流程序，可以看到输出⁠的工作流图结构（M⁠ermaid 语法）：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/UvPEdGiqO3DAmJvO.webp)

以及每一步工作流的节点执行和状态信息：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/m2Vc2vnMWgaLtuuv.webp)

可以将文本绘图的代码复制到 [Mermaid 可视化工具](https://mermaid-live.nodejs.cn/edit) 来验证下流程：

![](https://www.codefather.cn/_next/static/media/defaultCode.6873fc9a.png)

### 定义状态

需要将各个工作节点中共享的数据定义为状态。

#### 1、梳理状态

用一个表格来梳理：



|工作步骤|输入状态|输出状态|
|---|---|---|
|图片收集|originalPrompt 原始提示词|images 图片资源列表每一个图片都应该是对象结构（图片类别、描述、地址）图片类别：content 内容图片URLsillustration 插画图片URLsarchitecture 架构图URLlogo Logo图片URL|
|提示词增强|originalPrompt 原始提示词 images 图片资源|enhancedPrompt 增强后的提示词，包含图片描述和引用|
|智能路由⁠|originalPromptenhancedPrompt 增强后的提示词|generationT⁠ype 生成类型|
|代码生成|enhancedPromptgenerationType 生成类型images|generatedCodeDir 生成的代码目录|
|项目构建|generatedCodeDir 生成的代码目录|buildResultDir 构建成功的目录|

#### 2、定义状态类

还记得么？官方提供的默认状态类是 **消息列表** 结构：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/EuSJEKnLmPsANjmN.webp)

但显然，我们需要维护的状态包含多个字段，应该是⁠一个 Map 或者类的结构，因⁠此我们不如定义一个自己的 WorkflowContext 上下文类，统一维护所有需要的字段。

而且为了和 LangGraph4j 工作流图需要的 AgentState 兼容，我们可以将 WorkflowContext 对象作为一个 key / value 存放在 MessageState 中，需要使用时通过 `state.data().getKey` 获取即可。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/JiS9YFUpQNZrSeHQ.webp)

在 `langgraph4j.state` 包下新建工作流上下文类：

```java
/**
 * 工作流上下文 - 存储所有状态信息
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WorkflowContext implements Serializable {

    /**
     * WorkflowContext 在 MessagesState 中的存储key
     */
    public static final String WORKFLOW_CONTEXT_KEY = "workflowContext";

    /**
     * 当前执行步骤
     */
    private String currentStep;

    /**
     * 用户原始输入的提示词
     */
    private String originalPrompt;

    /**
     * 图片资源字符串
     */
    private String imageListStr;

    /**
     * 图片资源列表
     */
    private List<ImageResource> imageList;

    /**
     * 增强后的提示词
     */
    private String enhancedPrompt;

    /**
     * 代码生成类型
     */
    private CodeGenTypeEnum generationType;

    /**
     * 生成的代码目录
     */
    private String generatedCodeDir;

    /**
     * 构建成功的目录
     */
    private String buildResultDir;

    /**
     * 错误信息
     */
    private String errorMessage;

    @Serial
    private static final long serialVersionUID = 1L;

    // ========== 上下文操作方法 ==========

    /**
     * 从 MessagesState 中获取 WorkflowContext
     */
    public static WorkflowContext getContext(MessagesState<String> state) {
        return (WorkflowContext) state.data().get(WORKFLOW_CONTEXT_KEY);
    }

    /**
     * 将 WorkflowContext 保存到 MessagesState 中
     */
    public static Map<String, Object> saveContext(WorkflowContext context) {
        return Map.of(WORKFLOW_CONTEXT_KEY, context);
    }
}
```

ImageResource 类：

```java
/**
 * 图片资源对象
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ImageResource implements Serializable {

    /**
     * 图片类别
     */
    private ImageCategoryEnum category;

    /**
     * 图片描述
     */
    private String description;

    /**
     * 图片地址
     */
    private String url;

    @Serial
    private static final long serialVersionUID = 1L;
}
```

图片类型枚举类：

```java
@Getter
public enum ImageCategoryEnum {

    CONTENT("内容图片", "CONTENT"),
    LOGO("LOGO图片", "LOGO"),
    ILLUSTRATION("插画图片", "ILLUSTRATION"),
    ARCHITECTURE("架构图片", "ARCHITECTURE");


    private final String text;

    private final String value;

    ImageCategoryEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

    /**
     * 根据 value 获取枚举
     *
     * @param value 枚举值的value
     * @return 枚举值
     */
    public static ImageCategoryEnum getEnumByValue(String value) {
        if (ObjUtil.isEmpty(value)) {
            return null;
        }
        for (ImageCategoryEnum anEnum : ImageCategoryEnum.values()) {
            if (anEnum.value.equals(value)) {
                return anEnum;
            }
        }
        return null;
    }
}
```

#### 3、修改工作流图 - 引入状态

完善上一步得到的简单工作流：

1.  创建带状态感知的工作节点（能够读取和设置状态），只需要先获取到 WorkflowContext，修改字段后再保存即可。
2.  执行工作流时，传入初始上下文对象

完整代码如下：

```java
/**
 * 简化版带状态定义的工作流 - 只定义状态结构，不实现具体流转
 */
@Slf4j
public class SimpleStatefulWorkflowApp {

    /**
     * 创建带状态感知的工作节点
     */
    static AsyncNodeAction<MessagesState<String>> makeStatefulNode(String nodeName, String message) {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: {} - {}", nodeName, message);
            // 只记录当前步骤，不做具体的状态流转
            if (context != null) {
                context.setCurrentStep(nodeName);
            }
            return WorkflowContext.saveContext(context);
        });
    }

    public static void main(String[] args) throws GraphStateException {
        // 创建工作流图
        CompiledGraph<MessagesState<String>> workflow = new MessagesStateGraph<String>()
                // 添加节点 - 使用带状态感知的节点
                .addNode("image_collector", makeStatefulNode("image_collector", "获取图片素材"))
                .addNode("prompt_enhancer", makeStatefulNode("prompt_enhancer", "增强提示词"))
                .addNode("router", makeStatefulNode("router", "智能路由选择"))
                .addNode("code_generator", makeStatefulNode("code_generator", "网站代码生成"))
                .addNode("project_builder", makeStatefulNode("project_builder", "项目构建"))

                // 添加边
                .addEdge(START, "image_collector")
                .addEdge("image_collector", "prompt_enhancer")
                .addEdge("prompt_enhancer", "router")
                .addEdge("router", "code_generator")
                .addEdge("code_generator", "project_builder")
                .addEdge("project_builder", END)

                // 编译工作流
                .compile();

        // 初始化 WorkflowContext - 只设置基本信息
        WorkflowContext initialContext = WorkflowContext.builder()
                .originalPrompt("创建一个鱼皮的个人博客网站")
                .currentStep("初始化")
                .build();

        log.info("初始输入: {}", initialContext.getOriginalPrompt());
        log.info("开始执行工作流");

        // 显示工作流图
        GraphRepresentation graph = workflow.getGraph(GraphRepresentation.Type.MERMAID);
        log.info("工作流图:\n{}", graph.content());

        // 执行工作流
        int stepCounter = 1;
        for (NodeOutput<MessagesState<String>> step : workflow.stream(Map.of(WorkflowContext.WORKFLOW_CONTEXT_KEY, initialContext))) {
            log.info("--- 第 {} 步完成 ---", stepCounter);
            // 显示当前状态
            WorkflowContext currentContext = WorkflowContext.getContext(step.state());
            if (currentContext != null) {
                log.info("当前步骤上下文: {}", currentContext);
            }
            stepCounter++;
        }
        log.info("工作流执行完成！");
    }
}
```

执行并查看输出结果，应该和之⁠前一样，能够看到每⁠一个步骤的状态。

### 定义工作节点 - 模拟状态流转

#### 1、定义工作节点

在 `langgraph4j.node` 包下新建每一个步骤对应的工作节点，每个节点中只需要 Mock 一些假数据来模拟状态流转，不用真正实现业务逻辑。

图片收集节点：

```java
@Slf4j
public class ImageCollectorNode {
    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 图片收集");
            
            // TODO: 实际执行图片收集逻辑
            
            // 简单的假数据
            List<ImageResource> imageList = Arrays.asList(
                ImageResource.builder()
                    .category(ImageCategoryEnum.CONTENT)
                    .description("假数据图片1")
                    .url("https://www.codefather.cn/logo.png")
                    .build(),
                ImageResource.builder()
                    .category(ImageCategoryEnum.LOGO)
                    .description("假数据图片2")
                    .url("https://www.codefather.cn/logo.png")
                    .build()
            );
            
            // 更新状态
            context.setCurrentStep("图片收集");
            context.setImageList(imageList);
            log.info("图片收集完成，共收集 {} 张图片", imageList.size());
            return WorkflowContext.saveContext(context);
        });
    }
}
```

提示词增强节点：

```java
@Slf4j
public class PromptEnhancerNode {
    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 提示词增强");
            
            // TODO: 实际执行提示词增强逻辑
            
            // 简单的假数据
            String enhancedPrompt = "这是增强后的假数据提示词";
            
            // 更新状态
            context.setCurrentStep("提示词增强");
            context.setEnhancedPrompt(enhancedPrompt);
            log.info("提示词增强完成");
            return WorkflowContext.saveContext(context);
        });
    }
}
```

智能路由节点：

```java
@Slf4j
public class RouterNode {
    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 智能路由");
            
            // TODO: 实际执行智能路由逻辑
            
            // 简单的假数据
            CodeGenTypeEnum generationType = CodeGenTypeEnum.HTML;
            // 更新状态
            context.setCurrentStep("智能路由");
            context.setGenerationType(generationType);
            log.info("路由决策完成，选择类型: {}", generationType.getText());
            return WorkflowContext.saveContext(context);
        });
    }
}
```

代码生成节点：

```java
@Slf4j
public class CodeGeneratorNode {
    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 代码生成");
            
            // TODO: 实际执行代码生成逻辑
            
            // 简单的假数据
            String generatedCodeDir = "/tmp/generated/fake-code";
            // 更新状态
            context.setCurrentStep("代码生成");
            context.setGeneratedCodeDir(generatedCodeDir);
            log.info("代码生成完成，目录: {}", generatedCodeDir);
            return WorkflowContext.saveContext(context);
        });
    }
}
```

项目构建节点：

```java
@Slf4j
public class ProjectBuilderNode {
    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 项目构建");
            
            // TODO: 实际执行项目构建逻辑
            
            // 简单的假数据
            String buildResultDir = "/tmp/build/fake-build";
            
            // 更新状态
            context.setCurrentStep("项目构建");
            context.setBuildResultDir(buildResultDir);
            log.info("项目构建完成，结果目录: {}", buildResultDir);
            return WorkflowContext.saveContext(context);
        });
    }
}
```

#### 2、工作流图应用工作节点

`langgraph4j` 包下新建一个 WorkflowApp，应用各个工作节点类，代码如下：

```java
@Slf4j
public class WorkflowApp {

    public static void main(String[] args) throws GraphStateException {
        // 创建工作流图
        CompiledGraph<MessagesState<String>> workflow = new MessagesStateGraph<String>()
                // 添加节点 - 使用真实的工作节点
                .addNode("image_collector", ImageCollectorNode.create())
                .addNode("prompt_enhancer", PromptEnhancerNode.create())
                .addNode("router", RouterNode.create())
                .addNode("code_generator", CodeGeneratorNode.create())
                .addNode("project_builder", ProjectBuilderNode.create())
                // 添加边
                .addEdge(START, "image_collector")
                .addEdge("image_collector", "prompt_enhancer")
                .addEdge("prompt_enhancer", "router")
                .addEdge("router", "code_generator")
                .addEdge("code_generator", "project_builder")
                .addEdge("project_builder", END)
                // 编译工作流
                .compile();

        // 初始化 WorkflowContext - 只设置基本信息
        WorkflowContext initialContext = WorkflowContext.builder()
                .originalPrompt("创建一个鱼皮的个人博客网站")
                .currentStep("初始化")
                .build();
        log.info("初始输入: {}", initialContext.getOriginalPrompt());
        log.info("开始执行工作流");

        // 显示工作流图
        GraphRepresentation graph = workflow.getGraph(GraphRepresentation.Type.MERMAID);
        log.info("工作流图:\n{}", graph.content());

        // 执行工作流
        int stepCounter = 1;
        for (NodeOutput<MessagesState<String>> step : workflow.stream(Map.of(WorkflowContext.WORKFLOW_CONTEXT_KEY, initialContext))) {
            log.info("--- 第 {} 步完成 ---", stepCounter);
            // 显示当前状态
            WorkflowContext currentContext = WorkflowContext.getContext(step.state());
            if (currentContext != null) {
                log.info("当前步骤上下文: {}", currentContext);
            }
            stepCounter++;
        }
        log.info("工作流执行完成！");
    }
}
```

执行并查看输出结果，应该和之⁠前一样，能够看到每⁠一个步骤的状态。

接下来，需要依次开发真实的工作节点，工作量不小。

### 图片收集节点

图片收集节点的作用是根据用户提示词获取到网站所需的图片。

我们怎么知道网站需要什么图片呢？

不妨让 AI 来判断吧！通过给 AI 提供各种⁠不同类型的图片收集工具，来 A⁠I 调用工具来获取网站所需的不同类型的图片，并且直接利用结构化输出特性获取到最终的图片列表。

#### 1、内容图片收集工具

对于大多数普通的图片（比如物品图片、人物图片），可以直接在免费的图片网站搜索获取。比如 [Pexels 免费图片资源](https://www.pexels.com/api/) 提供了 API，能够让我们轻松地根据关键词来获取图片。

先到 Pexels 注册，并生成 API 密钥：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/g2mo3PujszNumxAi.webp "null")

参考 [API 文档](https://www.pexels.com/api/)，编写内容图片收集工具的代码，工作流需要用到的工具统一放到 `langgraph4j.tools` 包下：

```java
@Slf4j
@Component
public class ImageSearchTool {

    private static final String PEXELS_API_URL = "https://api.pexels.com/v1/search";

    @Value("${pexels.api-key}")
    private String pexelsApiKey;

    @Tool("搜索内容相关的图片，用于网站内容展示")
    public List<ImageResource> searchContentImages(@P("搜索关键词") String query) {
        List<ImageResource> imageList = new ArrayList<>();
        int searchCount = 12;
        // 调用 API，注意释放资源
        try (HttpResponse response = HttpRequest.get(PEXELS_API_URL)
                .header("Authorization", pexelsApiKey)
                .form("query", query)
                .form("per_page", searchCount)
                .form("page", 1)
                .execute()) {
            if (response.isOk()) {
                JSONObject result = JSONUtil.parseObj(response.body());
                JSONArray photos = result.getJSONArray("photos");
                for (int i = 0; i < photos.size(); i++) {
                    JSONObject photo = photos.getJSONObject(i);
                    JSONObject src = photo.getJSONObject("src");
                    imageList.add(ImageResource.builder()
                            .category(ImageCategoryEnum.CONTENT)
                            .description(photo.getStr("alt", query))
                            .url(src.getStr("medium"))
                            .build());
                }
            }
        } catch (Exception e) {
            log.error("Pexels API 调用失败: {}", e.getMessage(), e);
        }
        return imageList;
    }
}
```

填写配置：

```yaml
# Pexels 图片搜索配置
pexels:
  api-key: <Your API Key>
```

编写单元测试：

```java
@SpringBootTest
class ImageSearchToolTest {

    @Resource
    private ImageSearchTool imageSearchTool;

    @Test
    void testSearchContentImages() {
        // 测试正常搜索
        List<ImageResource> images = imageSearchTool.searchContentImages("technology");
        assertNotNull(images);
        assertFalse(images.isEmpty());
        // 验证返回的图片资源
        ImageResource firstImage = images.get(0);
        assertEquals(ImageCategoryEnum.CONTENT, firstImage.getCategory());
        assertNotNull(firstImage.getDescription());
        assertNotNull(firstImage.getUrl());
        assertTrue(firstImage.getUrl().startsWith("http"));
        System.out.println("搜索到 " + images.size() + " 张图片");
        images.forEach(image ->
                System.out.println("图片: " + image.getDescription() + " - " + image.getUrl())
        );
    }
}
```

执行单元测试，效果如图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/CgayEZqiakbOz2rP.webp "null")

#### 2、插画图片收集工具

可以通过免费插画图片网站 [unDraw](https://undraw.co/) 的接口获取，通过开发者工具获取到接口地址为：[https://undraw.co/\_next/data/mMWmJSt23qpgo8cLTD\_pB/search/happy.json?term=happy](https://undraw.co/_next/data/mMWmJSt23qpgo8cLTD_pB/search/happy.json?term=happy)

返回值示例：

```json
{
  "pageProps": {
    "initialResults": [
      {
        "_id": "6744eb233c000f0016260c54",
        "title": "Happy",
        "newSlug": "happy_kals",
        "
      }
    ]
  }
}
```

编写工具类代码：

```java
@Slf4j
@Component
public class UndrawIllustrationTool {

    private static final String UNDRAW_API_URL = "https://undraw.co/_next/data/mMWmJSt23qpgo8cLTD_pB/search/%s.json?term=%s";

    @Tool("搜索插画图片，用于网站美化和装饰")
    public List<ImageResource> searchIllustrations(@P("搜索关键词") String query) {
        List<ImageResource> imageList = new ArrayList<>();
        int searchCount = 12;
        String apiUrl = String.format(UNDRAW_API_URL, query, query);

        // 使用 try-with-resources 自动释放 HTTP 资源
        try (HttpResponse response = HttpRequest.get(apiUrl).timeout(10000).execute()) {
            if (!response.isOk()) {
                return imageList;
            }
            JSONObject result = JSONUtil.parseObj(response.body());
            JSONObject pageProps = result.getJSONObject("pageProps");
            if (pageProps == null) {
                return imageList;
            }
            JSONArray initialResults = pageProps.getJSONArray("initialResults");
            if (initialResults == null || initialResults.isEmpty()) {
                return imageList;
            }
            int actualCount = Math.min(searchCount, initialResults.size());
            for (int i = 0; i < actualCount; i++) {
                JSONObject illustration = initialResults.getJSONObject(i);
                String title = illustration.getStr("title", "插画");
                String media = illustration.getStr("media", "");
                if (StrUtil.isNotBlank(media)) {
                    imageList.add(ImageResource.builder()
                            .category(ImageCategoryEnum.ILLUSTRATION)
                            .description(title)
                            .url(media)
                            .build());
                }
            }
        } catch (Exception e) {
            log.error("搜索插画失败：{}", e.getMessage(), e);
        }
        return imageList;
    }
}
```

编写单元测试：

```java
@SpringBootTest
class UndrawIllustrationToolTest {

    @Resource
    private UndrawIllustrationTool undrawIllustrationTool;

    @Test
    void testSearchIllustrations() {
        // 测试正常搜索插画
        List<ImageResource> illustrations = undrawIllustrationTool.searchIllustrations("happy");
        assertNotNull(illustrations);
        // 验证返回的插画资源
        ImageResource firstIllustration = illustrations.get(0);
        assertEquals(ImageCategoryEnum.ILLUSTRATION, firstIllustration.getCategory());
        assertNotNull(firstIllustration.getDescription());
        assertNotNull(firstIllustration.getUrl());
        assertTrue(firstIllustration.getUrl().startsWith("http"));
        System.out.println("搜索到 " + illustrations.size() + " 张插画");
        illustrations.forEach(illustration -> 
            System.out.println("插画: " + illustration.getDescription() + " - " + illustration.getUrl())
        );
    }
}
```

执行单元测试，效果如图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/HAidc9to7uUrdSsi.webp "null")

#### 3、架构图绘制工具

由于架构图是需要根据特定的描述来定制的，⁠不能直接上网搜索，因此我们⁠的思路是将 AI 调用工具时传入的 Mermaid 文本绘图代码转换成图片。

这里有几种方案：

1）mermaid-cli + COS（推荐）：先利用 Mermaid CLI 工具将文本绘图代码转换为图片，之后上传到 COS 对象存储拿到对应的 URL 地址方便后续使用。

2）Mermaid 文本生图 API：比如 [Kroki](https://kroki.io/)、[Mermaid Ink](http://mermaid.ink/) 等，可以直接在线生成。优点是使用方便缺点，缺点是生成慢、而且图片地址太长！

![](https://pic.code-nav.cn/course_picture/1608440217629360130/GtnX21HsDNzVdYo0.webp)

3）Mermaid 文本生图 MCP：有一些 [开源的 MCP 服务](https://github.com/peng-shawn/mermaid-mcp-server)，优点是使用方便，缺点是不方便定制、而且图片会交给别人来存储。

推荐方案一，实现成本也不大。

首先安装必备的 mermaid-cli 工具：

```shell
npm install -g @mermaid-js/mermaid-cli
```

编写工具代码，通过调用终端执⁠行 mermaid⁠-cli 命令将文本转为图片，然后上传到 COS 对象存储中：

```java
@Slf4j
@Component
public class MermaidDiagramTool {

    @Resource
    private CosManager cosManager;
    
    @Tool("将 Mermaid 代码转换为架构图图片，用于展示系统结构和技术关系")
    public List<ImageResource> generateMermaidDiagram(@P("Mermaid 图表代码") String mermaidCode,
                                                      @P("架构图描述") String description) {
        if (StrUtil.isBlank(mermaidCode)) {
            return new ArrayList<>();
        }
        try {
            // 转换为SVG图片
            File diagramFile = convertMermaidToSvg(mermaidCode);
            // 上传到COS
            String keyName = String.format("/mermaid/%s/%s",
                    RandomUtil.randomString(5), diagramFile.getName());
            String cosUrl = cosManager.uploadFile(keyName, diagramFile);
            // 清理临时文件
            FileUtil.del(diagramFile);
            if (StrUtil.isNotBlank(cosUrl)) {
                return Collections.singletonList(ImageResource.builder()
                        .category(ImageCategoryEnum.ARCHITECTURE)
                        .description(description)
                        .url(cosUrl)
                        .build());
            }
        } catch (Exception e) {
            log.error("生成架构图失败: {}", e.getMessage(), e);
        }
        return new ArrayList<>();
    }

    /**
     * 将Mermaid代码转换为SVG图片
     */
    private File convertMermaidToSvg(String mermaidCode) {
        // 创建临时输入文件
        File tempInputFile = FileUtil.createTempFile("mermaid_input_", ".mmd", true);
        FileUtil.writeUtf8String(mermaidCode, tempInputFile);
        // 创建临时输出文件
        File tempOutputFile = FileUtil.createTempFile("mermaid_output_", ".svg", true);
        // 根据操作系统选择命令
        String command = SystemUtil.getOsInfo().isWindows() ? "mmdc.cmd" : "mmdc";
        // 构建命令
        String cmdLine = String.format("%s -i %s -o %s -b transparent",
                command,
                tempInputFile.getAbsolutePath(),
                tempOutputFile.getAbsolutePath()
        );
        // 执行命令
        RuntimeUtil.execForStr(cmdLine);
        // 检查输出文件
        if (!tempOutputFile.exists() || tempOutputFile.length() == 0) {
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "Mermaid CLI 执行失败");
        }
        // 清理输入文件，保留输出文件供上传使用
        FileUtil.del(tempInputFile);
        return tempOutputFile;
    }
}
```

上述代码中的几个注意事项：

1.  通过 Hutool 的 `SystemUtil.getOsInfo().isWindows()` 判断操作系统
2.  通过 Hutool 的 `RuntimeUtil` 执行终端命令

编写单元测试：

```java
@SpringBootTest
class MermaidDiagramToolTest {

    @Resource
    private MermaidDiagramTool mermaidDiagramTool;

    @Test
    void testGenerateMermaidDiagram() {
        // 测试生成 Mermaid 架构图
        String mermaidCode = """
                flowchart LR
                    Start([开始]) --> Input[输入数据]
                    Input --> Process[处理数据]
                    Process --> Decision{是否有效?}
                    Decision -->|是| Output[输出结果]
                    Decision -->|否| Error[错误处理]
                    Output --> End([结束])
                    Error --> End
                """;
        String description = "简单系统架构图";
        List<ImageResource> diagrams = mermaidDiagramTool.generateMermaidDiagram(mermaidCode, description);
        assertNotNull(diagrams);
        // 如果有结果，验证图表资源
        ImageResource firstDiagram = diagrams.get(0);
        assertEquals(ImageCategoryEnum.ARCHITECTURE, firstDiagram.getCategory());
        assertEquals(description, firstDiagram.getDescription());
        assertNotNull(firstDiagram.getUrl());
        assertTrue(firstDiagram.getUrl().startsWith("http"));
        System.out.println("生成了架构图: " + firstDiagram.getUrl());
    }
}
```

执行单元测试，效果如图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/QSXCtJSyKX3MsnNC.webp "null")

#### 4、Logo 图片生成工具

由于 Logo 图片也是需要根据文字⁠定制生成的，因此需要用到⁠ AI 文生图模型，或者文生图 MCP 服务（比如 MiniMax）。

此处选择接入阿里云百炼平台的⁠ AI 大模型，会⁠比 MCP 服务更灵活。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/s5Ku6ICyCnJ2YB1l.webp)

用法参考官方文档：

-   SDK 文档：[https://bailian.console.aliyun.com/?type=model&tab=api#/api/?type=model&url=https%3A%2F%2Fhelp.aliyun.com%2Fdocument\_detail%2F2712193.html&renderType=iframe](https://bailian.console.aliyun.com/?type=model&tab=api#/api/?type=model&url=https%3A%2F%2Fhelp.aliyun.com%2Fdocument_detail%2F2712193.html&renderType=iframe)
-   文生图 API 参考：[https://help.aliyun.com/zh/model-studio/text-to-image-v2-api-reference](https://help.aliyun.com/zh/model-studio/text-to-image-v2-api-reference)

1）引入依赖：

```xml
<!-- 阿里云 DashScope SDK -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>dashscope-sdk-java</artifactId>
    <version>2.21.1</version>
</dependency>
```

2）从控制台 [获取 API Key](https://bailian.console.aliyun.com/?type=model&tab=model#/api-key)：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/nf0RMvL2lrcNy0pv.webp)

编写配置：

```yaml
# 阿里云 DashScope 配置
dashscope:
  api-key: <Your API Key>
  image-model: wan2.2-t2i-flash
```

3）编写工具类代码，读取配置⁠并构造向 AI 的⁠请求，然后得到图片列表。

```java
@Slf4j
@Component
public class LogoGeneratorTool {

    @Value("${dashscope.api-key:}")
    private String dashScopeApiKey;

    @Value("${dashscope.image-model:wan2.2-t2i-flash}")
    private String imageModel;

    @Tool("根据描述生成 Logo 设计图片，用于网站品牌标识")
    public List<ImageResource> generateLogos(@P("Logo 设计描述，如名称、行业、风格等，尽量详细") String description) {
        List<ImageResource> logoList = new ArrayList<>();
        try {
            // 构建 Logo 设计提示词
            String logoPrompt = String.format("生成 Logo，Logo 中禁止包含任何文字！Logo 介绍：%s", description);
            ImageSynthesisParam param = ImageSynthesisParam.builder()
                    .apiKey(dashScopeApiKey)
                    .model(imageModel)
                    .prompt(logoPrompt)
                    .size("512*512")
                    .n(1) // 生成 1 张足够，因为 AI 不知道哪张最好
                    .build();
            ImageSynthesis imageSynthesis = new ImageSynthesis();
            ImageSynthesisResult result = imageSynthesis.call(param);
            if (result != null && result.getOutput() != null && result.getOutput().getResults() != null) {
                List<Map<String, String>> results = result.getOutput().getResults();
                for (Map<String, String> imageResult : results) {
                    String imageUrl = imageResult.get("url");
                    if (StrUtil.isNotBlank(imageUrl)) {
                        logoList.add(ImageResource.builder()
                                .category(ImageCategoryEnum.LOGO)
                                .description(description)
                                .url(imageUrl)
                                .build());
                    }
                }
            }
        } catch (Exception e) {
            log.error("生成 Logo 失败: {}", e.getMessage(), e);
        }
        return logoList;
    }
}
```

注意，虽然 API 支持一次性生成多张图片，但对我们来⁠说 1 张足够了，能省则省，毕竟程序⁠也判断不出来要用哪张 Logo。不过返回值还是使用列表，这时为了便于 AI 理解，生成失败就是列表为空。

这玩意挺贵的：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/1FTjFNXHhbi89Bwy.webp)

编写单元测试：

```java
@SpringBootTest
class LogoGeneratorToolTest {

    @Resource
    private LogoGeneratorTool logoGeneratorTool;

    @Test
    void testGenerateLogos() {
        // 测试生成Logo
        List<ImageResource> logos = logoGeneratorTool.generateLogos("技术公司现代简约风格Logo");
        assertNotNull(logos);
        ImageResource firstLogo = logos.getFirst();
        assertEquals(ImageCategoryEnum.LOGO, firstLogo.getCategory());
        assertNotNull(firstLogo.getDescription());
        assertNotNull(firstLogo.getUrl());
        logos.forEach(logo ->
                System.out.println("Logo: " + logo.getDescription() + " - " + logo.getUrl())
        );
    }
}
```

执行单元测试，效果如图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/VAieXJqXgr0B866G.webp "null")

💡 注意，模型生成的图像存储于阿里云 OSS，每张图像会被分配一个OSS链接，如`https://dashscope-result-xx.oss-cn-xxxx.aliyuncs.com/xxx.png`。OSS 链接允许公开访问，可以使用此链接查看或者下载图片，**但是链接仅在 24 小时内有效**。因此建议将图片下载并保存到自己的对象存储中。

#### 5、图片收集 AI 服务

写一段 AI 收集图片的提示词，单独保存在资源文件 `image-collection-system-prompt.txt` 中：

```markdown
你是一个专业的图片收集助手。根据用户的网站需求，智能选择并调用相应的工具收集不同类型的图片资源。

你可以根据需要调用下面多个工具，收集全面的图片资源：
1. searchContentImages - 搜索内容相关图片，用于网站内容展示
2. searchIllustrations - 搜索插画图片，用于网站美化和装饰  
3. generateArchitectureDiagram - 根据技术主题生成架构图，用于展示系统结构和技术关系
4. generateLogos - 根据描述生成Logo设计图片，用于网站品牌标识

请根据用户的需求分析，优先选择与用户需求最相关的图片类型：
- 如果涉及技术、系统、架构等内容，调用 generateArchitectureDiagram 生成架构图
- 如果需要品牌标识、Logo设计，调用 generateLogos 生成Logo
- 如果需要内容相关图片，调用 searchContentImages 搜索图片
- 如果需要装饰性插画，调用 searchIllustrations 搜索插画

你必须按照 JSON 格式输出！
```

然后编写图片收集 AI 服⁠务。理想情况下 AI⁠ 服务肯定是采用结构化输出：

```java
/**
 * 图片收集 AI 服务接口
 * 使用 AI 调用工具收集不同类型的图片资源
 */
public interface ImageCollectionService {

    /**
     * 根据用户提示词收集所需的图片资源
     * AI 会根据需求自主选择调用相应的工具
     */
    @SystemMessage(fromResource = "prompt/image-collection-system-prompt.txt")
    List<ImageResource> collectImages(@UserMessage String userPrompt);
}
```

但由于我们返回的是 `List<POJO>` 类型，这里会遇到一些坑！

首先，要配置结构化输出的 [JSON Schema](https://docs.langchain4j.dev/tutorials/structured-outputs#supported-types)，必须要开启下列设置才能支持返回这种类型：

```java
supportedCapabilities(RESPONSE_FORMAT_JSON_SCHEMA)
```

![](https://pic.code-nav.cn/course_picture/1608440217629360130/HrS3qu8JuyiWmcQR.webp)

否则会报错：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/7jyIseXHhU2rEh4N.webp "null")

但是，DeepSeek 模型又不支持这个参数！咋办？

这里鱼皮先尝试了 [阿里云百炼模型](https://help.aliyun.com/zh/model-studio/use-qwen-by-calling-api)，因为它也兼容 Open AI，但是必须要在提示词中引导 AI 回复 JSON 格式：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/LR785Zx0A6GXMBZw.webp)

否则会报错：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/XQTafKjhF0Dm0RC6.webp "null")

结果，我测试阿里云百炼大模型⁠时发现，AI 的工⁠具调用意图被错误地尝试解析为结构化输出的返回值：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/A84m2ldEI1ry4Jjj.webp "null")

所以，最终的解决方案是使用 DeepSeek 模型，⁠但是不使用结构化输出能力，方法直接⁠返回 String，在后续的提示词增强节点中直接使用 AI 输出的信息即可，干脆就不结构化了。

因此可以先复用原有的 Cha⁠tModel 配置⁠，无需新自定义 ChatModel。

1）在 `langgraph4j.ai` 包下创建图片收集 AI 服务：

```java
public interface ImageCollectionService {

    /**
     * 根据用户提示词收集所需的图片资源
     * AI 会根据需求自主选择调用相应的工具
     */
    @SystemMessage(fromResource = "prompt/image-collection-system-prompt.txt")
    String collectImages(@UserMessage String userPrompt);
}
```

2）创建 AI 服务创建工厂⁠，注入指定的 ch⁠atModel 和各种图片收集工具：

```java
@Slf4j
@Configuration
public class ImageCollectionServiceFactory {

    @Resource
    private ChatModel chatModel;

    @Resource
    private ImageSearchTool imageSearchTool;

    @Resource
    private UndrawIllustrationTool undrawIllustrationTool;

    @Resource
    private MermaidDiagramTool mermaidDiagramTool;

    @Resource
    private LogoGeneratorTool logoGeneratorTool;

    /**
     * 创建图片收集 AI 服务
     */
    @Bean
    public ImageCollectionService createImageCollectionService() {
        return AiServices.builder(ImageCollectionService.class)
                .chatModel(chatModel)
                .tools(
                        imageSearchTool,
                        undrawIllustrationTool,
                        mermaidDiagramTool,
                        logoGeneratorTool
                )
                .build();
    }
}
```

3）给 WorkflowCo⁠ntext 状态新⁠增图片资源字符串字段，用于接收 AI 输出的图片信息：

```java
/**
 * 图片资源字符串
 */
private String imageListStr;
```

4）编写单元测试，验证 AI 图片收集服务：

```java
@SpringBootTest
class ImageCollectionServiceTest {

    @Resource
    private ImageCollectionService imageCollectionService;

    @Test
    void testTechWebsiteImageCollection() {
        String result = imageCollectionService.collectImages("创建一个技术博客网站，需要展示编程教程和系统架构");
        Assertions.assertNotNull(result);
        System.out.println("技术网站收集到的图片: " + result);
    }

    @Test
    void testEcommerceWebsiteImageCollection() {
        String result = imageCollectionService.collectImages("创建一个电商购物网站，需要展示商品和品牌形象");
        Assertions.assertNotNull(result);
        System.out.println("电商网站收集到的图片: " + result);
    }
}
```

执行效果如图，还挺不错的：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/XmxbvY9LTYuWxa8F.webp)

#### 6、工作节点开发

工作节点需要调用 AI 服务⁠收集图片，并更新状⁠态的 imageListStr 字段。

由于目前我们的工作节点类都是通过静态方法提供工作节点的，可以写一个获取 Spring Bean 的静态工具类，就可以在静态方法中获取到 `ImageCollectionService` 了，这样就不用修改原本的代码。

```java
/**
 * Spring上下文工具类
 * 用于在静态方法中获取Spring Bean
 */
@Component
public class SpringContextUtil implements ApplicationContextAware {

    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        SpringContextUtil.applicationContext = applicationContext;
    }

    /**
     * 获取Spring Bean
     */
    public static <T> T getBean(Class<T> clazz) {
        return applicationContext.getBean(clazz);
    }

    /**
     * 获取Spring Bean
     */
    public static Object getBean(String name) {
        return applicationContext.getBean(name);
    }

    /**
     * 根据名称和类型获取Spring Bean
     */
    public static <T> T getBean(String name, Class<T> clazz) {
        return applicationContext.getBean(name, clazz);
    }
}
```

在静态方法中获取指定 Bean：

```java
// 获取AI图片收集服务
ImageCollectionService imageCollectionService = SpringContextUtil.getBean(ImageCollectionService.class);
```

代码如下：

```java
/**
 * 图片收集节点
 * 使用AI进行工具调用，收集不同类型的图片
 */
@Slf4j
public class ImageCollectorNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            String originalPrompt = context.getOriginalPrompt();
            String imageListStr = "";
            try {
                // 获取AI图片收集服务
                ImageCollectionService imageCollectionService = SpringContextUtil.getBean(ImageCollectionService.class);
                // 使用 AI 服务进行智能图片收集
                imageListStr = imageCollectionService.collectImages(originalPrompt);
                imageCollectionService.collectImages(originalPrompt);
            } catch (Exception e) {
                log.error("图片收集失败: {}", e.getMessage(), e);
            }
            // 更新状态
            context.setCurrentStep("图片收集");
            context.setImageListStr(imageListStr);
            return WorkflowContext.saveContext(context);
        });
    }
}
```

### 提示词增强节点

将获取到的图片信息拼接到原始⁠提示词下，并在拼接⁠提示词时引导 AI 利用这些图片信息作为网站素材。

拼接的提示词示例：

```markdown
## 可用素材资源
请在生成网站使用以下图片资源，将这些图片合理地嵌入到网站的相应位置中。
- 架构图：编程学习网站架构（https://www.codefather.cn/logo.png）
- Logo图片：编程导航学习圈的 Logo（https://www.codefather.cn/logo.png）
```

编写工作节点代码：

```java
@Slf4j
public class PromptEnhancerNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 提示词增强");
            // 获取原始提示词和图片列表
            String originalPrompt = context.getOriginalPrompt();
            String imageListStr = context.getImageListStr();
            List<ImageResource> imageList = context.getImageList();
            // 构建增强后的提示词
            StringBuilder enhancedPromptBuilder = new StringBuilder();
            enhancedPromptBuilder.append(originalPrompt);
            // 如果有图片资源，则添加图片信息
            if (CollUtil.isNotEmpty(imageList) || StrUtil.isNotBlank(imageListStr)) {
                enhancedPromptBuilder.append("\n\n## 可用素材资源\n");
                enhancedPromptBuilder.append("请在生成网站使用以下图片资源，将这些图片合理地嵌入到网站的相应位置中。\n");
                if (CollUtil.isNotEmpty(imageList)) {
                    for (ImageResource image : imageList) {
                        enhancedPromptBuilder.append("- ")
                                .append(image.getCategory().getText())
                                .append("：")
                                .append(image.getDescription())
                                .append("（")
                                .append(image.getUrl())
                                .append("）\n");
                    }
                } else {
                    enhancedPromptBuilder.append(imageListStr);
                }
            }
            String enhancedPrompt = enhancedPromptBuilder.toString();
            // 更新状态
            context.setCurrentStep("提示词增强");
            context.setEnhancedPrompt(enhancedPrompt);
            log.info("提示词增强完成，增强后长度: {} 字符", enhancedPrompt.length());
            return WorkflowContext.saveContext(context);
        });
    }
}
```

注意，拼接提示词时要兼容读取图⁠片列表字符串、以及图⁠片对象列表。虽然现在图片对象列表没有赋值，但之后我们会优化。

### 智能路由节点

根据用户的原始提示词选择对应的网站生成方式，利用项目已有的 `AiCodeGenTypeRoutingService` 实现即可，逻辑参考 `createApp` 方法的实现。

编写智能路由工作节点：

```java
@Slf4j
public class RouterNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 智能路由");

            CodeGenTypeEnum generationType;
            try {
                // 获取AI路由服务
                AiCodeGenTypeRoutingService routingService = SpringContextUtil.getBean(AiCodeGenTypeRoutingService.class);
                // 根据原始提示词进行智能路由
                generationType = routingService.routeCodeGenType(context.getOriginalPrompt());
                log.info("AI智能路由完成，选择类型: {} ({})", generationType.getValue(), generationType.getText());
            } catch (Exception e) {
                log.error("AI智能路由失败，使用默认HTML类型: {}", e.getMessage());
                generationType = CodeGenTypeEnum.HTML;
            }

            // 更新状态
            context.setCurrentStep("智能路由");
            context.setGenerationType(generationType);
            return WorkflowContext.saveContext(context);
        });
    }
}
```

### 代码生成节点

首先根据代码生成类型，调用 `AiCodeGeneratorFacade` 生成代码，获得流式输出。然后还需要同步等待流式输出完成，将代码生成目录保存到状态中，交给下一个工作节点去处理。

代码生成工作节点代码如下：

```java
@Slf4j
public class CodeGeneratorNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 代码生成");

            // 使用增强提示词作为发给 AI 的用户消息
            String userMessage = context.getEnhancedPrompt();
            CodeGenTypeEnum generationType = context.getGenerationType();
            // 获取 AI 代码生成外观服务
            AiCodeGeneratorFacade codeGeneratorFacade = SpringContextUtil.getBean(AiCodeGeneratorFacade.class);
            log.info("开始生成代码，类型: {} ({})", generationType.getValue(), generationType.getText());
            // 先使用固定的 appId (后续再整合到业务中)
            Long appId = 0L;
            // 调用流式代码生成
            Flux<String> codeStream = codeGeneratorFacade.generateAndSaveCodeStream(userMessage, generationType, appId);
            // 同步等待流式输出完成
            codeStream.blockLast(Duration.ofMinutes(10)); // 最多等待 10 分钟
            // 根据类型设置生成目录
            String generatedCodeDir = String.format("%s/%s_%s", AppConstant.CODE_OUTPUT_ROOT_DIR, generationType.getValue(), appId);
            log.info("AI 代码生成完成，生成目录: {}", generatedCodeDir);

            // 更新状态
            context.setCurrentStep("代码生成");
            context.setGeneratedCodeDir(generatedCodeDir);
            return WorkflowContext.saveContext(context);
        });
    }
}
```

### 项目构建节点

如果是 Vue 工程项目类型，调用项目已有的 ⁠VueProjectBuild⁠er 打包构建；如果是其他类型，直接忽略（因为上一步文件已经通过 AI 工具调用保存）。

项目构建节点的代码如下：

```java
@Slf4j
public class ProjectBuilderNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 项目构建");

            // 获取必要的参数
            String generatedCodeDir = context.getGeneratedCodeDir();
            CodeGenTypeEnum generationType = context.getGenerationType();
            String buildResultDir;
            // Vue 项目类型：使用 VueProjectBuilder 进行构建
            if (generationType == CodeGenTypeEnum.VUE_PROJECT) {
                try {
                    VueProjectBuilder vueBuilder = SpringContextUtil.getBean(VueProjectBuilder.class);
                    // 执行 Vue 项目构建（npm install + npm run build）
                    boolean buildSuccess = vueBuilder.buildProject(generatedCodeDir);
                    if (buildSuccess) {
                        // 构建成功，返回 dist 目录路径
                        buildResultDir = generatedCodeDir + File.separator + "dist";
                        log.info("Vue 项目构建成功，dist 目录: {}", buildResultDir);
                    } else {
                        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "Vue 项目构建失败");
                    }
                } catch (Exception e) {
                    log.error("Vue 项目构建异常: {}", e.getMessage(), e);
                    buildResultDir = generatedCodeDir; // 异常时返回原路径
                }
            } else {
                // HTML 和 MULTI_FILE 代码生成时已经保存了，直接使用生成的代码目录
                buildResultDir = generatedCodeDir;
            }

            // 更新状态
            context.setCurrentStep("项目构建");
            context.setBuildResultDir(buildResultDir);
            log.info("项目构建节点完成，最终目录: {}", buildResultDir);
            return WorkflowContext.saveContext(context);
        });
    }
}
```

### 工作流使用工作节点

最后，将原本的 WorkflowApp 改造为一⁠个新的工作流 CodeGenWo⁠rkflow，作为正式可用的类。不再是通过 main 方法运行，而是提供执行工作流的方法。

代码如下：

```java
@Slf4j
public class CodeGenWorkflow {

    /**
     * 创建完整的工作流
     */
    public CompiledGraph<MessagesState<String>> createWorkflow() {
        try {
            return new MessagesStateGraph<String>()
                    // 添加节点 - 使用完整实现的节点
                    .addNode("image_collector", ImageCollectorNode.create())
                    .addNode("prompt_enhancer", PromptEnhancerNode.create())
                    .addNode("router", RouterNode.create())
                    .addNode("code_generator", CodeGeneratorNode.create())
                    .addNode("project_builder", ProjectBuilderNode.create())

                    // 添加边
                    .addEdge(START, "image_collector")
                    .addEdge("image_collector", "prompt_enhancer")
                    .addEdge("prompt_enhancer", "router")
                    .addEdge("router", "code_generator")
                    .addEdge("code_generator", "project_builder")
                    .addEdge("project_builder", END)

                    // 编译工作流
                    .compile();
        } catch (GraphStateException e) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "工作流创建失败");
        }
    }

    /**
     * 执行工作流
     */
    public WorkflowContext executeWorkflow(String originalPrompt) {
        CompiledGraph<MessagesState<String>> workflow = createWorkflow();

        // 初始化 WorkflowContext
        WorkflowContext initialContext = WorkflowContext.builder()
                .originalPrompt(originalPrompt)
                .currentStep("初始化")
                .build();

        GraphRepresentation graph = workflow.getGraph(GraphRepresentation.Type.MERMAID);
        log.info("工作流图:\n{}", graph.content());
        log.info("开始执行代码生成工作流");

        WorkflowContext finalContext = null;
        int stepCounter = 1;
        for (NodeOutput<MessagesState<String>> step : workflow.stream(
                Map.of(WorkflowContext.WORKFLOW_CONTEXT_KEY, initialContext))) {
            log.info("--- 第 {} 步完成 ---", stepCounter);
            // 显示当前状态
            WorkflowContext currentContext = WorkflowContext.getContext(step.state());
            if (currentContext != null) {
                finalContext = currentContext;
                log.info("当前步骤上下文: {}", currentContext);
            }
            stepCounter++;
        }
        log.info("代码生成工作流执行完成！");
        return finalContext;
    }
}
```

### 测试

最后，编写单元测试来验证目前完整的工作流：

```java
@SpringBootTest
class CodeGenWorkflowTest {

    @Test
    void testTechBlogWorkflow() {
        WorkflowContext result = new CodeGenWorkflow().executeWorkflow("创建一个技术博客网站，需要展示编程教程和系统架构");
        Assertions.assertNotNull(result);
        System.out.println("生成类型: " + result.getGenerationType());
        System.out.println("生成的代码目录: " + result.getGeneratedCodeDir());
        System.out.println("构建结果目录: " + result.getBuildResultDir());
    }

    @Test
    void testCorporateWorkflow() {
        WorkflowContext result = new CodeGenWorkflow().executeWorkflow("创建企业官网，展示公司形象和业务介绍");
        Assertions.assertNotNull(result);
        System.out.println("生成类型: " + result.getGenerationType());
        System.out.println("生成的代码目录: " + result.getGeneratedCodeDir());
        System.out.println("构建结果目录: " + result.getBuildResultDir());
    }

    @Test
    void testVueProjectWorkflow() {
        WorkflowContext result = new CodeGenWorkflow().executeWorkflow("创建一个Vue前端项目，包含用户管理和数据展示功能");
        Assertions.assertNotNull(result);
        System.out.println("生成类型: " + result.getGenerationType());
        System.out.println("生成的代码目录: " + result.getGeneratedCodeDir());
        System.out.println("构建结果目录: " + result.getBuildResultDir());
    }

    @Test
    void testSimpleHtmlWorkflow() {
        WorkflowContext result = new CodeGenWorkflow().executeWorkflow("创建一个简单的个人主页");
        Assertions.assertNotNull(result);
        System.out.println("生成类型: " + result.getGenerationType());
        System.out.println("生成的代码目录: " + result.getGeneratedCodeDir());
        System.out.println("构建结果目录: " + result.getBuildResultDir());
    }
}
```

这里举个例子，比如让 AI ⁠做个技术博客，可以⁠通过 Debug 查看状态：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/sEc8LQhr2AylznBx.webp)

查看生成的网站效果，已经得到了内容相关的图片：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/yGkRIqrXqBXAaDpy.webp)

显然，比之前用随机占位图片的效果要好很多：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/t5ZEbrQeo2uT4oxp.webp)

## 五、LangGraph4j 工作流特性实战

刚刚我们已经跑通了核心的工作⁠流，但是好像还没有⁠体现出工作流的优势，就是利用工作流把逻辑串起来了而已。

其实 LangGraph4j⁠ 工作流还有更多特⁠性，让我们来依次实战。

### 跳过构建 - 条件边

对于 HTML 和 MULTI\_F⁠ILE 网站生成类型，⁠网站生成工作节点中已经会自动保存网站文件，不需要进入项目构建节点。

除了在项目构建工作节点中写 if-else 外，还可以使用 [LangGraph4j 的条件边特性](https://langgraph4j.github.io/langgraph4j/core/low_level/#conditional-edges)：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/OMRGwjtGaFyIQNtT.webp)

1）工作流新增路由函数和条件边配置：

```java
.addEdge("router", "code_generator")
// 使用条件边：根据代码生成类型决定是否需要构建
.addConditionalEdges("code_generator",
        edge_async(this::routeBuildOrSkip),
        Map.of(
                "build", "project_builder",  // 需要构建的情况
                "skip_build", END             // 跳过构建直接结束
        ))
.addEdge("project_builder", END)
```

💡 如果多次用到同一工作节⁠点的 key，建议⁠统一放到常量类中维护。

2）路由函数决定代码生成后是否需要项目构建：

```java
private String routeBuildOrSkip(MessagesState<String> state) {
    WorkflowContext context = WorkflowContext.getContext(state);
    CodeGenTypeEnum generationType = context.getGenerationType();
    // HTML 和 MULTI_FILE 类型不需要构建，直接结束
    if (generationType == CodeGenTypeEnum.HTML || generationType == CodeGenTypeEnum.MULTI_FILE) {
        return "skip_build";
    }
    // VUE_PROJECT 需要构建
    return "build";
}
```

3）项目构建工作节点中移除 if-else 逻辑：

```java
String buildResultDir;
// 一定是 Vue 项目类型：使用 VueProjectBuilder 进行构建
try {
    VueProjectBuilder vueBuilder = SpringContextUtil.getBean(VueProjectBuilder.class);
    // 执行 Vue 项目构建（npm install + npm run build）
    boolean buildSuccess = vueBuilder.buildProject(generatedCodeDir);
    if (buildSuccess) {
        // 构建成功，返回 dist 目录路径
        buildResultDir = generatedCodeDir + File.separator + "dist";
        log.info("Vue 项目构建成功，dist 目录: {}", buildResultDir);
    } else {
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "Vue 项目构建失败");
    }
} catch (Exception e) {
    log.error("Vue 项目构建异常: {}", e.getMessage(), e);
    buildResultDir = generatedCodeDir; // 异常时返回原路径
}
```

这种设计比在 ProjectBuil⁠derNode 中写 i⁠f-else 更加优雅，符合 LangGraph4j 和工作流的设计理念。

用条件边的优势是：

1.  可视化更清晰：工作流图能直观显示不同路径
2.  性能更好：直接跳过不需要的节点，避免无用的 Bean 加载
3.  关注点分离：节点专注业务逻辑，边专注流程控制

### 质量检查 - 循环边

新增代码质检 Agent 工作节点，⁠在生成代码后，检验代码是⁠否有异常、能否正常打包，如果有异常则返回到网站生成 Agent 重新生成。

该节点所需的状态：`generatedCodeDir` + `generationType`

该节点返回的状态：`qualityResult` 质检结果

-   `isValid` 是否通过
-   `errors` 错误列表
-   `suggestions` 改进建议

具体怎么检查呢？

我的想法是开发一个工具来读取并拼接项目生成的所有代码文件，让 A⁠I 来检查；如果有问题，回到网站生成 Ag⁠ent，提示词中额外拼接检查得到的错误列表和改进建议，让 AI 在现有代码基础上进行修改，而不是完全从 0 开始生成。

#### 方案思考

奇怪了，检查代码质量是否过关⁠不应该是个判断逻辑⁠么？为什么采用工作节点，而不是条件边来实现呢？

这里我们全都要，应该用：**工作节点 + 条件边的组合**

原因如下：

1）代码质检本身是一个复杂的工作任务：

-   需要读取并拼接代码文件
-   调用 AI 进行代码分析
-   生成质检结果（错误、建议等）
-   这是实际的业务逻辑，应该用工作节点

2）根据质检结果的路由决策：

-   质检通过 → 继续到项目构建
-   质检失败 → 回到代码生成节点
-   这是流程控制逻辑，应该用条件边

二者组合，形成了完整的工作流程：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/DD33LQ1Q1drgEGb4.webp)

💡 其实可以专门再提供一个 `项目修复节点`，接受检查出的错误信息，并使用修复项目提示词。区分创建和修改，效果可能会更佳。

下面进行开发。

#### 1、定义数据模型

`langgraph4j.model` 下增加 `QualityResult` 类：

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class QualityResult implements Serializable {
    
    @Serial
    private static final long serialVersionUID = 1L;
    
    /**
     * 是否通过质检
     */
    private Boolean isValid;
    
    /**
     * 错误列表
     */
    private List<String> errors;
    
    /**
     * 改进建议
     */
    private List<String> suggestions;
}
```

WorkflowContext 状态补充字段：

```java
/**
 * 质量检查结果
 */
private QualityResult qualityResult;
```

#### 2、质量检查 AI 服务

1）编写质量检查 AI 提示词 `code-quality-check-system-prompt.txt`，提示词重点突出 **检查语法错误**，并且强调结构化输出的 JSON 格式。

```markdown
你是一个专业的代码质量检查专家。你的任务是分析用户提供的网站代码，检查语法错误等方面的问题，确保项目可以正常运行和打包。

## 检查重点

### 1. 语法和结构错误
- HTML 标签是否正确闭合
- CSS 语法是否正确
- JavaScript 语法错误
- 文件引用路径是否正确
- 缺失的依赖或资源

### 2. 代码质量
- 代码结构是否合理
- 命名规范是否一致
- 代码重复性检查

### 3. 功能完整性
- 页面功能是否完整
- 交互逻辑是否正确
- 响应式设计检查

## 输出格式

请严格按照以下 JSON 格式返回检查结果：

json
{
  "isValid": true/false,
  "errors": [
    "具体的错误描述1",
    "具体的错误描述2"
  ],
  "suggestions": [
    "改进建议1",
    "改进建议2"
  ]
}


 ## 判断标准

- isValid = true: 代码无严重语法错误，能够正常运行和打包
- isValid = false: 存在语法错误、结构问题或其他会导致无法正常运行的问题
- errors: 必须修复的问题，如语法错误、缺失文件等
- suggestions: 关于如何修复错误和改进代码的建议

请仔细分析代码，提供专业的质量检查结果。
```

2）开发 AI 服务，利用结构化输出：

```java
public interface CodeQualityCheckService {

    /**
     * 检查代码质量
     * AI 会分析代码并返回质量检查结果
     */
    @SystemMessage(fromResource = "prompt/code-quality-check-system-prompt.txt")
    QualityResult checkCodeQuality(@UserMessage String codeContent);
}
```

3）开发创建 AI 服务的工厂：

```java
@Slf4j
@Configuration
public class CodeQualityCheckServiceFactory {

    @Resource
    private ChatModel chatModel;

    /**
     * 创建代码质量检查 AI 服务
     */
    @Bean
    public CodeQualityCheckService createCodeQualityCheckService() {
        return AiServices.builder(CodeQualityCheckService.class)
                .chatModel(chatModel)
                .build();
    }
}
```

#### 3、开发质量检查工作节点

代码较复杂，我们可以分为 2 步完成。

1）开发一个方法来读取生成代码⁠的文件结构和具体内容⁠，拼接好后交给 AI 来检查，可以利用 Hutool 工具类完成。

```java
/**
 * 需要检查的文件扩展名
 */
private static final List<String> CODE_EXTENSIONS = Arrays.asList(
        ".html", ".htm", ".css", ".js", ".json", ".vue", ".ts", ".jsx", ".tsx"
);

/**
 * 读取并拼接代码目录下的所有代码文件
 */
private static String readAndConcatenateCodeFiles(String codeDir) {
    if (StrUtil.isBlank(codeDir)) {
        return "";
    }
    File directory = new File(codeDir);
    if (!directory.exists() || !directory.isDirectory()) {
        log.error("代码目录不存在或不是目录: {}", codeDir);
        return "";
    }
    StringBuilder codeContent = new StringBuilder();
    codeContent.append("# 项目文件结构和代码内容\n\n");
    // 使用 Hutool 的 walkFiles 方法遍历所有文件
    FileUtil.walkFiles(directory, file -> {
        // 过滤条件：跳过隐藏文件、特定目录下的文件、非代码文件
        if (shouldSkipFile(file, directory)) {
            return;
        }
        if (isCodeFile(file)) {
            String relativePath = FileUtil.subPath(directory.getAbsolutePath(), file.getAbsolutePath());
            codeContent.append("## 文件: ").append(relativePath).append("\n\n");
            String fileContent = FileUtil.readUtf8String(file);
            codeContent.append(fileContent).append("\n\n");
        }
    });
    return codeContent.toString();
}

/**
 * 判断是否应该跳过此文件
 */
private static boolean shouldSkipFile(File file, File rootDir) {
    String relativePath = FileUtil.subPath(rootDir.getAbsolutePath(), file.getAbsolutePath());
    // 跳过隐藏文件
    if (file.getName().startsWith(".")) {
        return true;
    }
    // 跳过特定目录下的文件
    return relativePath.contains("node_modules" + File.separator) ||
            relativePath.contains("dist" + File.separator) ||
            relativePath.contains("target" + File.separator) ||
            relativePath.contains(".git" + File.separator);
}

/**
 * 判断是否是需要检查的代码文件
 */
private static boolean isCodeFile(File file) {
    String fileName = file.getName().toLowerCase();
    return CODE_EXTENSIONS.stream().anyMatch(fileName::endsWith);
}
```

💡 上述代码中，用到了 Hu⁠tool 的 wal⁠kFiles 方法来遍历文件，这里用到了设计模式 —— 访问者模式。

访问者模式允许你在不修改对象结构的情况下，定义作用于这些对象的新操作。在这个例子中，walkF⁠iles 方法遍历文件树结构，而我们传入的 lambda 表达⁠式就是访问者，它定义了对每个文件要执行的具体操作。这样的设计让文件遍历逻辑和文件处理逻辑完全分离，可以灵活地定义不同的文件处理策略，而不需要修改遍历文件的核心代码。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/2cxzIXNCchhGdxfL.webp)

2）开发具体的代码质量检查逻⁠辑，调用 AI 完⁠成检查，并更新质量检查结果状态：

```java
/**
 * 代码质量检查节点
 */
@Slf4j
public class CodeQualityCheckNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            log.info("执行节点: 代码质量检查");
            String generatedCodeDir = context.getGeneratedCodeDir();
            QualityResult qualityResult;
            try {
                // 1. 读取并拼接代码文件内容
                String codeContent = readAndConcatenateCodeFiles(generatedCodeDir);
                if (StrUtil.isBlank(codeContent)) {
                    log.warn("未找到可检查的代码文件");
                    qualityResult = QualityResult.builder()
                            .isValid(false)
                            .errors(List.of("未找到可检查的代码文件"))
                            .suggestions(List.of("请确保代码生成成功"))
                            .build();
                } else {
                    // 2. 调用 AI 进行代码质量检查
                    CodeQualityCheckService qualityCheckService = SpringContextUtil.getBean(CodeQualityCheckService.class);
                    qualityResult = qualityCheckService.checkCodeQuality(codeContent);
                    log.info("代码质量检查完成 - 是否通过: {}", qualityResult.getIsValid());
                }
            } catch (Exception e) {
                log.error("代码质量检查异常: {}", e.getMessage(), e);
                qualityResult = QualityResult.builder()
                        .isValid(true) // 异常直接跳到下一个步骤
                        .build();
            }
            // 3. 更新状态
            context.setCurrentStep("代码质量检查");
            context.setQualityResult(qualityResult);
            return WorkflowContext.saveContext(context);
        });
    }
}
```

#### 4、修改代码生成节点

代码生成节点要判断状态中有没⁠有错误信息，如果有⁠的话，需要根据错误信息构造提示词，引导 AI 修复错误。

1）编写构造用户消息的方法，⁠如果存在质检失败结⁠果则添加错误修复信息：

```java
/**
 * 构造用户消息，如果存在质检失败结果则添加错误修复信息
 */
private static String buildUserMessage(WorkflowContext context) {
    String userMessage = context.getEnhancedPrompt();
    // 检查是否存在质检失败结果
    QualityResult qualityResult = context.getQualityResult();
    if (isQualityCheckFailed(qualityResult)) {
        // 直接将错误修复信息作为新的提示词（起到了修改的作用）
        userMessage = buildErrorFixPrompt(qualityResult);
    }
    return userMessage;
}

/**
 * 判断质检是否失败
 */
private static boolean isQualityCheckFailed(QualityResult qualityResult) {
    return qualityResult != null && 
           !qualityResult.getIsValid() && 
           qualityResult.getErrors() != null && 
           !qualityResult.getErrors().isEmpty();
}

/**
 * 构造错误修复提示词
 */
private static String buildErrorFixPrompt(QualityResult qualityResult) {
    StringBuilder errorInfo = new StringBuilder();
    errorInfo.append("\n\n## 上次生成的代码存在以下问题，请修复：\n");
    // 添加错误列表
    qualityResult.getErrors().forEach(error -> 
        errorInfo.append("- ").append(error).append("\n"));
    // 添加修复建议（如果有）
    if (qualityResult.getSuggestions() != null && !qualityResult.getSuggestions().isEmpty()) {
        errorInfo.append("\n## 修复建议：\n");
        qualityResult.getSuggestions().forEach(suggestion -> 
            errorInfo.append("- ").append(suggestion).append("\n"));
    }
    errorInfo.append("\n请根据上述问题和建议重新生成代码，确保修复所有提到的问题。");
    return errorInfo.toString();
}
```

2）节点方法中调用构造用户消息：

```java
// 构造用户消息（包含原始提示词和可能的错误修复信息）
String userMessage = buildUserMessage(context);
```

#### 5、修改工作流

1）新增节点和边，质检条件边可以和之前的构建条件边合并：

```java
.addNode("code_quality_check", CodeQualityCheckNode.create())
// ...
.addEdge("code_generator", "code_quality_check")
// 新增质检条件边：根据质检结果决定下一步
.addConditionalEdges("code_quality_check",
        edge_async(this::routeAfterQualityCheck),
        Map.of(
                "build", "project_builder",   // 质检通过且需要构建
                "skip_build", END,            // 质检通过但跳过构建
                "fail", "code_generator"      // 质检失败，重新生成
        ))
```

2）新写一个路由函数，根据质检结果决定下一步，直接复用之前的 `routeBuildOrSkip` 方法：

```java
private String routeAfterQualityCheck(MessagesState<String> state) {
    WorkflowContext context = WorkflowContext.getContext(state);
    QualityResult qualityResult = context.getQualityResult();
    // 如果质检失败，重新生成代码
    if (qualityResult == null || !qualityResult.getIsValid()) {
        log.error("代码质检失败，需要重新生成代码");
        return "fail";
    }
    // 质检通过，使用原有的构建路由逻辑
    log.info("代码质检通过，继续后续流程");
    return routeBuildOrSkip(state);
}
```

#### 6、单元测试

执行之前开发的工作流单元测试，可以看⁠到 AI 给出修改建议的⁠同时，isValid 仍然为 true，并没有触发多余的修改，效果不错：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Hq33c00jMgc5Nh1i.webp)

### 图片收集优化 - 并发和子图

目前通过工具调用获取图片需要⁠和 AI 进行多轮⁠交互，不仅耗费时间长、性能低、还会消耗大量 token。

#### 优化方案

其实可以转变思路，先通过调用 AI 获取⁠要收集的图片类别和参数（输⁠出图片收集任务），利用结构化输出返回这些信息，然后并发调用对应的图片收集工具执行。

接下来，具体的并发实现方案有 3 种：

1）工作节点内部实现并发（推荐）

在图片收集节点内部通过 Co⁠mpletable⁠Future 并发调用工具进行收集，并更新结果。

2）利用 LangGraph4j 的并发能力

把每个图片收集工具定义成工作⁠节点，并发执行这些⁠工具，最后再统一汇总结果。

3）利用 LangGraph4j 的子图能力

把每个图片收集工具定义成子图⁠，并发执行这些工具⁠，最后再统一汇总结果。

其实 2 和 3 的思路类似，⁠但是建议只有并发分支⁠下有多个步骤时，才考虑使用子图能力，否则就有点为了封装而封装了。

#### 图片收集规划实现

1）编写 AI 收集图片的提示词 `image-collection-plan-system-prompt.txt`：

```markdown
你是一个专业的图片收集规划师。你的任务是分析用户的网站需求，制定合理的图片收集计划。

## 图片类型说明

### 1. 内容图片 (contentImageTasks)
- 用途：网站的主要内容配图
- 来源：通过关键词搜索获取
- 示例：产品图片、场景图片、人物图片等

### 2. 插画图片 (illustrationTasks) 
- 用途：装饰性插画，提升页面美观度
- 来源：Undraw 插画库
- 示例：抽象插画、概念图解等

### 3. 架构图 (diagramTasks)
- 用途：展示系统架构、流程图等技术图表
- 来源：通过 Mermaid 代码生成
- 示例：系统架构图、流程图、组织结构图等

### 4. Logo图片 (logoTasks)
- 用途：品牌标识、图标等
- 来源：AI 生成
- 示例：公司Logo、产品图标等

## 规划原则

1. 需求导向：根据用户描述的网站类型和用途来规划图片
2. 适量原则：每种类型的图片数量要合理，避免过多或过少
3. 关键词精准：选择最能体现需求的关键词
4. 描述清晰：为任务提供清晰的描述说明

## 输出要求

请严格按照以下 JSON 格式返回图片收集计划：

json
{
  "contentImageTasks": [
    {
      "query": "搜索关键词"
    }
  ],
  "illustrationTasks": [
    {
      "query": "插画关键词"
    }
  ],
  "diagramTasks": [
    {
      "mermaidCode": "mermaid图表代码",
      "description": "图表用途描述"
    }
  ],
  "logoTasks": [
    {
      "description": "Logo设计描述，如名称、行业、风格等"
    }
  ]
}


注意：
- 如果某种类型的图片不需要，对应数组可以为空
- 每个任务的 description 要说明图片的具体用途和位置
- mermaidCode 要是有效的 Mermaid 语法代码
- 关键词要使用中文或英文，选择搜索效果最好的语言
```

2）在 `model` 包下定义 `ImageCollectionPlan` 数据模型，用于保存图片收集任务：

```java
@Data
public class ImageCollectionPlan implements Serializable {
    
    /**
     * 内容图片搜索任务列表
     */
    private List<ImageSearchTask> contentImageTasks;
    
    /**
     * 插画图片搜索任务列表
     */
    private List<IllustrationTask> illustrationTasks;
    
    /**
     * 架构图生成任务列表
     */
    private List<DiagramTask> diagramTasks;
    
    /**
     * Logo生成任务列表
     */
    private List<LogoTask> logoTasks;
    
    /**
     * 内容图片搜索任务
     * 对应 ImageSearchTool.searchContentImages(String query)
     */
    public record ImageSearchTask(String query) implements Serializable {}
    
    /**
     * 插画图片搜索任务
     * 对应 UndrawIllustrationTool.searchIllustrations(String query)
     */
    public record IllustrationTask(String query) implements Serializable {}
    
    /**
     * 架构图生成任务
     * 对应 MermaidDiagramTool.generateMermaidDiagram(String mermaidCode, String description)
     */
    public record DiagramTask(String mermaidCode, String description) implements Serializable {}
    
    /**
     * Logo生成任务
     * 对应 LogoGeneratorTool.generateLogos(String description)
     */
    public record LogoTask(String description) implements Serializable {}
}
```

上述代码中，使用 recor⁠d 来简化每种图片⁠搜集任务的定义。

3）编写图片收集 AI 服务

```java
public interface ImageCollectionPlanService {

    /**
     * 根据用户提示词分析需要收集的图片类型和参数
     */
    @SystemMessage(fromResource = "prompt/image-collection-plan-system-prompt.txt")
    ImageCollectionPlan planImageCollection(@UserMessage String userPrompt);
}
```

4）编写对应的 AI 服务工⁠厂，暂时先复用 C⁠hatModel 模型：

```java
@Configuration
public class ImageCollectionPlanServiceFactory {

    @Resource
    private ChatModel chatModel;

    @Bean
    public ImageCollectionPlanService createImageCollectionPlanService() {
        return AiServices.builder(ImageCollectionPlanService.class)
                .chatModel(chatModel)
                .build();
    }
}
```

#### CompletableFuture 并发实现（推荐）

直接修改图片收集工作节点。先调⁠用 AI 进行规划，⁠然后并发收集图片并汇总，最后设置 imageList 状态。

代码如下：

```java
@Slf4j
public class ImageCollectorNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            String originalPrompt = context.getOriginalPrompt();
            List<ImageResource> collectedImages = new ArrayList<>();
            
            try {
                // 第一步：获取图片收集计划
                ImageCollectionPlanService planService = SpringContextUtil.getBean(ImageCollectionPlanService.class);
                ImageCollectionPlan plan = planService.planImageCollection(originalPrompt);
                log.info("获取到图片收集计划，开始并发执行");
                
                // 第二步：并发执行各种图片收集任务
                List<CompletableFuture<List<ImageResource>>> futures = new ArrayList<>();
                // 并发执行内容图片搜索
                if (plan.getContentImageTasks() != null) {
                    ImageSearchTool imageSearchTool = SpringContextUtil.getBean(ImageSearchTool.class);
                    for (ImageCollectionPlan.ImageSearchTask task : plan.getContentImageTasks()) {
                        futures.add(CompletableFuture.supplyAsync(() -> 
                            imageSearchTool.searchContentImages(task.query())));
                    }
                }
                // 并发执行插画图片搜索
                if (plan.getIllustrationTasks() != null) {
                    UndrawIllustrationTool illustrationTool = SpringContextUtil.getBean(UndrawIllustrationTool.class);
                    for (ImageCollectionPlan.IllustrationTask task : plan.getIllustrationTasks()) {
                        futures.add(CompletableFuture.supplyAsync(() -> 
                            illustrationTool.searchIllustrations(task.query())));
                    }
                }
                // 并发执行架构图生成
                if (plan.getDiagramTasks() != null) {
                    MermaidDiagramTool diagramTool = SpringContextUtil.getBean(MermaidDiagramTool.class);
                    for (ImageCollectionPlan.DiagramTask task : plan.getDiagramTasks()) {
                        futures.add(CompletableFuture.supplyAsync(() -> 
                            diagramTool.generateMermaidDiagram(task.mermaidCode(), task.description())));
                    }
                }
                // 并发执行Logo生成
                if (plan.getLogoTasks() != null) {
                    LogoGeneratorTool logoTool = SpringContextUtil.getBean(LogoGeneratorTool.class);
                    for (ImageCollectionPlan.LogoTask task : plan.getLogoTasks()) {
                        futures.add(CompletableFuture.supplyAsync(() -> 
                            logoTool.generateLogos(task.description())));
                    }
                }
                
                // 等待所有任务完成并收集结果
                CompletableFuture<Void> allTasks = CompletableFuture.allOf(
                    futures.toArray(new CompletableFuture[0]));
                allTasks.join();
                // 收集所有结果
                for (CompletableFuture<List<ImageResource>> future : futures) {
                    List<ImageResource> images = future.get();
                    if (images != null) {
                        collectedImages.addAll(images);
                    }
                }
                log.info("并发图片收集完成，共收集到 {} 张图片", collectedImages.size());
            } catch (Exception e) {
                log.error("图片收集失败: {}", e.getMessage(), e);
            }
            // 更新状态
            context.setCurrentStep("图片收集");
            context.setImageList(collectedImages);
            return WorkflowContext.saveContext(context);
        });
    }
}
```

这种方案对调用方的改动最小，⁠而且把图片收集工作⁠聚合在了一个类中，最推荐这种方式。

执行单元测试，查看收集到的图片：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/TBXQu9tFDzGp061w.webp "null")

查看生成的网站，显然有了图片⁠规划后，网站的生成⁠效果好了很多！

![](https://pic.code-nav.cn/course_picture/1608440217629360130/z5ompvXPTcG051fv.webp "null")

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Pa201OUaIrRhZqg0.webp "null")

![](https://pic.code-nav.cn/course_picture/1608440217629360130/N3AYeEo9xMo8Wi9V.webp "null")

![](https://pic.code-nav.cn/course_picture/1608440217629360130/VjwzKBc3JMyqi5Nb.webp "null")

可以通过在图片收集节点内增加⁠ Spring 的⁠ StopWatch 来对比性能：

```java
// 开头计时
StopWatch stopWatch = new StopWatch();
stopWatch.start();

// ... 业务逻辑

// 结尾停止计时并输出结果
stopWatch.stop();
log.info("图片收集总耗时: {} ms", stopWatch.getTotalTimeMillis());
```

使用并发前：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Bp1lMd5c07g5uzpb.webp)

使用并发后，**性能提升了几倍，缩短了 70 多秒！**

![](https://pic.code-nav.cn/course_picture/1608440217629360130/8P835NKsjmLCWyer.webp)

💡 可以按需调整获取图片的最大数量，防止提示词过长。

#### LangGraph4j 并发实现

利用 LangGraph4j 的 [Parallel Branch](https://langgraph4j.github.io/langgraph4j/core/parallel-branch/) 特性，将每个图片收集工具都定义为一个工作节点，这些工作节点可并发执行。

工作流程变为：图片规划 => 并发收集 => 图片聚合

如图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/tCcpLBXnnmVDzqNP.webp)

WorkflowContext 状态新增字段：

```java
/**
 * 图片收集计划
 */
private ImageCollectionPlan imageCollectionPlan;


/**
 * 并发图片收集的中间结果字段
 */
private List<ImageResource> contentImages;
private List<ImageResource> illustrations;
private List<ImageResource> diagrams;
private List<ImageResource> logos;
```

在 `node.concurrent` 包下开发并发相关的新工作节点，包括：

-   1 个规划节点
-   4 个收集节点
-   1 个汇总节点

![](https://pic.code-nav.cn/course_picture/1608440217629360130/C77kjGvYlwm5XTKZ.webp)

接下来分别开发这些节点。

1）图片计划节点：分析用户需⁠求，生成图片收集计⁠划，为并发执行做准备

```java
@Slf4j
public class ImagePlanNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            String originalPrompt = context.getOriginalPrompt();
            try {
                // 获取图片收集计划服务
                ImageCollectionPlanService planService = SpringContextUtil.getBean(ImageCollectionPlanService.class);
                ImageCollectionPlan plan = planService.planImageCollection(originalPrompt);
                log.info("生成图片收集计划，准备启动并发分支");
                // 将计划存储到上下文中
                context.setImageCollectionPlan(plan);
                context.setCurrentStep("图片计划");
            } catch (Exception e) {
                log.error("图片计划生成失败: {}", e.getMessage(), e);
            }
            return WorkflowContext.saveContext(context);
        });
    }
}
```

2）内容图片收集节点：并发执⁠行内容图片搜索任务⁠（直接调用之前已开发的工具）

```java
@Slf4j
public class ContentImageCollectorNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            List<ImageResource> contentImages = new ArrayList<>();
            try {
                ImageCollectionPlan plan = context.getImageCollectionPlan();
                if (plan != null && plan.getContentImageTasks() != null) {
                    ImageSearchTool imageSearchTool = SpringContextUtil.getBean(ImageSearchTool.class);
                    log.info("开始并发收集内容图片，任务数: {}", plan.getContentImageTasks().size());
                    for (ImageCollectionPlan.ImageSearchTask task : plan.getContentImageTasks()) {
                        List<ImageResource> images = imageSearchTool.searchContentImages(task.query());
                        if (images != null) {
                            contentImages.addAll(images);
                        }
                    }
                    log.info("内容图片收集完成，共收集到 {} 张图片", contentImages.size());
                }
            } catch (Exception e) {
                log.error("内容图片收集失败: {}", e.getMessage(), e);
            }
            // 将收集到的图片存储到上下文的中间字段中
            context.setContentImages(contentImages);
            context.setCurrentStep("内容图片收集");
            return WorkflowContext.saveContext(context);
        });
    }
}
```

3）插画图片收集节点：

```java
@Slf4j
public class IllustrationCollectorNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            List<ImageResource> illustrations = new ArrayList<>();
            try {
                ImageCollectionPlan plan = context.getImageCollectionPlan();
                if (plan != null && plan.getIllustrationTasks() != null) {
                    UndrawIllustrationTool illustrationTool = SpringContextUtil.getBean(UndrawIllustrationTool.class);
                    log.info("开始并发收集插画图片，任务数: {}", plan.getIllustrationTasks().size());
                    for (ImageCollectionPlan.IllustrationTask task : plan.getIllustrationTasks()) {
                        List<ImageResource> images = illustrationTool.searchIllustrations(task.query());
                        if (images != null) {
                            illustrations.addAll(images);
                        }
                    }
                    log.info("插画图片收集完成，共收集到 {} 张图片", illustrations.size());
                }
            } catch (Exception e) {
                log.error("插画图片收集失败: {}", e.getMessage(), e);
            }
            context.setIllustrations(illustrations);
            context.setCurrentStep("插画图片收集");
            return WorkflowContext.saveContext(context);
        });
    }
}
```

4）架构图绘制节点：

```java
@Slf4j
public class DiagramCollectorNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            List<ImageResource> diagrams = new ArrayList<>();
            try {
                ImageCollectionPlan plan = context.getImageCollectionPlan();
                if (plan != null && plan.getDiagramTasks() != null) {
                    MermaidDiagramTool diagramTool = SpringContextUtil.getBean(MermaidDiagramTool.class);
                    log.info("开始并发生成架构图，任务数: {}", plan.getDiagramTasks().size());
                    for (ImageCollectionPlan.DiagramTask task : plan.getDiagramTasks()) {
                        List<ImageResource> images = diagramTool.generateMermaidDiagram(
                                task.mermaidCode(), task.description());
                        if (images != null) {
                            diagrams.addAll(images);
                        }
                    }
                    log.info("架构图生成完成，共生成 {} 张图片", diagrams.size());
                }
            } catch (Exception e) {
                log.error("架构图生成失败: {}", e.getMessage(), e);
            }
            context.setDiagrams(diagrams);
            context.setCurrentStep("架构图生成");
            return WorkflowContext.saveContext(context);
        });
    }
}
```

5）Logo 生成节点：

```java
@Slf4j
public class LogoCollectorNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            List<ImageResource> logos = new ArrayList<>();
            try {
                ImageCollectionPlan plan = context.getImageCollectionPlan();
                if (plan != null && plan.getLogoTasks() != null) {
                    LogoGeneratorTool logoTool = SpringContextUtil.getBean(LogoGeneratorTool.class);
                    log.info("开始并发生成Logo，任务数: {}", plan.getLogoTasks().size());
                    for (ImageCollectionPlan.LogoTask task : plan.getLogoTasks()) {
                        List<ImageResource> images = logoTool.generateLogos(task.description());
                        if (images != null) {
                            logos.addAll(images);
                        }
                    }
                    log.info("Logo生成完成，共生成 {} 张图片", logos.size());
                }
            } catch (Exception e) {
                log.error("Logo生成失败: {}", e.getMessage(), e);
            }
            context.setLogos(logos);
            context.setCurrentStep("Logo生成");
            return WorkflowContext.saveContext(context);
        });
    }
}
```

6）图片聚合节点：汇聚所有并发分支收集到的图片

```java
@Slf4j
public class ImageAggregatorNode {

    public static AsyncNodeAction<MessagesState<String>> create() {
        return node_async(state -> {
            WorkflowContext context = WorkflowContext.getContext(state);
            List<ImageResource> allImages = new ArrayList<>();
            log.info("开始聚合并发收集的图片");
            // 从各个中间字段聚合图片
            if (context.getContentImages() != null) {
                allImages.addAll(context.getContentImages());
            }
            if (context.getIllustrations() != null) {
                allImages.addAll(context.getIllustrations());
            }
            if (context.getDiagrams() != null) {
                allImages.addAll(context.getDiagrams());
            }
            if (context.getLogos() != null) {
                allImages.addAll(context.getLogos());
            }
            log.info("图片聚合完成，总共 {} 张图片", allImages.size());
            // 更新最终的图片列表
            context.setImageList(allImages);
            context.setCurrentStep("图片聚合");
            return WorkflowContext.saveContext(context);
        });
    }
}
```

___

编写一个新的工作流 `CodeGenConcurrentWorkflow`，使用 LangGraph4j 的并发能力实现图片收集的并发执行：

```java
@Slf4j
public class CodeGenConcurrentWorkflow {

    /**
     * 创建并发工作流
     */
    public CompiledGraph<MessagesState<String>> createWorkflow() {
        try {
            return new MessagesStateGraph<String>()
                    // 添加节点
                    .addNode("image_plan", ImagePlanNode.create())
                    .addNode("prompt_enhancer", PromptEnhancerNode.create())
                    .addNode("router", RouterNode.create())
                    .addNode("code_generator", CodeGeneratorNode.create())
                    .addNode("code_quality_check", CodeQualityCheckNode.create())
                    .addNode("project_builder", ProjectBuilderNode.create())

                    // 添加并发图片收集节点
                    .addNode("content_image_collector", ContentImageCollectorNode.create())
                    .addNode("illustration_collector", IllustrationCollectorNode.create())
                    .addNode("diagram_collector", DiagramCollectorNode.create())
                    .addNode("logo_collector", LogoCollectorNode.create())
                    .addNode("image_aggregator", ImageAggregatorNode.create())

                    // 添加边
                    .addEdge(START, "image_plan")

                    // 并发分支：从计划节点分发到各个收集节点
                    .addEdge("image_plan", "content_image_collector")
                    .addEdge("image_plan", "illustration_collector")
                    .addEdge("image_plan", "diagram_collector")
                    .addEdge("image_plan", "logo_collector")

                    // 汇聚：所有收集节点都汇聚到聚合器
                    .addEdge("content_image_collector", "image_aggregator")
                    .addEdge("illustration_collector", "image_aggregator")
                    .addEdge("diagram_collector", "image_aggregator")
                    .addEdge("logo_collector", "image_aggregator")

                    // 继续串行流程
                    .addEdge("image_aggregator", "prompt_enhancer")
                    .addEdge("prompt_enhancer", "router")
                    .addEdge("router", "code_generator")
                    .addEdge("code_generator", "code_quality_check")

                    // 质检条件边
                    .addConditionalEdges("code_quality_check",
                            edge_async(this::routeAfterQualityCheck),
                            Map.of(
                                    "build", "project_builder",
                                    "skip_build", END,
                                    "fail", "code_generator"
                            ))
                    .addEdge("project_builder", END)
                    .compile();
        } catch (GraphStateException e) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "并发工作流创建失败");
        }
    }

    /**
     * 执行并发工作流
     */
    public WorkflowContext executeWorkflow(String originalPrompt) {
        CompiledGraph<MessagesState<String>> workflow = createWorkflow();
        WorkflowContext initialContext = WorkflowContext.builder()
                .originalPrompt(originalPrompt)
                .currentStep("初始化")
                .build();
        GraphRepresentation graph = workflow.getGraph(GraphRepresentation.Type.MERMAID);
        log.info("并发工作流图:\n{}", graph.content());
        log.info("开始执行并发代码生成工作流");
        WorkflowContext finalContext = null;
        int stepCounter = 1;
        for (NodeOutput<MessagesState<String>> step : workflow.stream(
                Map.of(WorkflowContext.WORKFLOW_CONTEXT_KEY, initialContext)
        )) {
            log.info("--- 第 {} 步完成 ---", stepCounter);
            WorkflowContext currentContext = WorkflowContext.getContext(step.state());
            if (currentContext != null) {
                finalContext = currentContext;
                log.info("当前步骤上下文: {}", currentContext);
            }
            stepCounter++;
        }
        log.info("并发代码生成工作流执行完成！");
        return finalContext;
    }

    /**
     * 路由函数：根据质检结果决定下一步
     */
    private String routeAfterQualityCheck(MessagesState<String> state) {
        WorkflowContext context = WorkflowContext.getContext(state);
        QualityResult qualityResult = context.getQualityResult();

        if (qualityResult == null || !qualityResult.getIsValid()) {
            log.error("代码质检失败，需要重新生成代码");
            return "fail";
        }
        log.info("代码质检通过，继续后续流程");
        CodeGenTypeEnum generationType = context.getGenerationType();
        if (generationType == CodeGenTypeEnum.VUE_PROJECT) {
            return "build";
        } else {
            return "skip_build";
        }
    }
}
```

上述代码中，我们只需要为同一⁠个工作节点创造连接⁠到多个不同图片收集工作节点的边，框架就会自动作为并发分支处理。

接下来，我们编写并发代码生成工作流的单元测试：

```java
@SpringBootTest
class CodeGenConcurrentWorkflowTest {

    @Test
    void testConcurrentWorkflow() {
        WorkflowContext result = new CodeGenConcurrentWorkflow().executeWorkflow("创建一个技术博客网站，需要展示编程教程和系统架构");
        Assertions.assertNotNull(result);
        System.out.println("生成类型: " + result.getGenerationType());
        System.out.println("生成的代码目录: " + result.getGeneratedCodeDir());
        System.out.println("构建结果目录: " + result.getBuildResultDir());
        System.out.println("收集的图片数量: " + (result.getImageList() != null ? result.getImageList().size() : 0));
    }

    @Test
    void testEcommerceWorkflow() {
        WorkflowContext result = new CodeGenConcurrentWorkflow().executeWorkflow("创建一个电子商务网站，需要商品展示、购物车和支付功能");
        Assertions.assertNotNull(result);
        System.out.println("生成类型: " + result.getGenerationType());
        System.out.println("生成的代码目录: " + result.getGeneratedCodeDir());
        System.out.println("收集的图片数量: " + (result.getImageList() != null ? result.getImageList().size() : 0));
    }
}
```

执行单元测试，但是查看日志发现竟然还是按顺序串行执行的？！

![](https://pic.code-nav.cn/course_picture/1608440217629360130/L659FsUEBlvL2yMT.webp)

这时由于之前 LangGraph4j 的旧版本是不支持并发的，即使按照要求写代码，并发分支仍然是串行执行；从 `1.6.0-rc2` 版本后，就支持配置线程池了。

相关 issue 信息：

-   [https://github.com/langgraph4j/langgraph4j/issues/151](https://github.com/langgraph4j/langgraph4j/issues/151)
-   [https://github.com/langgraph4j/langgraph4j/discussions/191](https://github.com/langgraph4j/langgraph4j/discussions/191)

需要配置线程池和运行时配置：

```java
// 配置并发执行
ExecutorService pool = ExecutorBuilder.create()
        .setCorePoolSize(10)
        .setMaxPoolSize(20)
        .setWorkQueue(new LinkedBlockingQueue<>(100))
        .setThreadFactory(ThreadFactoryBuilder.create().setNamePrefix("Parallel-Image-Collect").build())
        .build();
RunnableConfig runnableConfig = RunnableConfig.builder()
        .addParallelNodeExecutor("image_plan", pool)
        .build();
for (NodeOutput<MessagesState<String>> step : workflow.stream(
        Map.of(WorkflowContext.WORKFLOW_CONTEXT_KEY, initialContext),
        runnableConfig)) {}
```

再次执行单元测试，这次并发生效：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Zp3GJQ7QMduTlPgB.webp)

等并发分支都执行完后，才会进行下一步聚合图片：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/wCnUYG2nZNlX84j7.webp)

#### LangGraph4j 子图实现

其实在目前我们的场景里是用不到 [子图](https://langgraph4j.github.io/langgraph4j/core/parallel-branch/#use-compiled-sub-graph-as-parallel-node) 的，此处只是给大家作为示例。如果并发分支步骤超出 1 个，再考虑使用。

![](https://pic.code-nav.cn/course_picture/1608440217629360130/yNW4SzhKhfKWW7uV.webp)

还记得子图的 3 种创建方式么？

1.  直接添加：这种方式会将子图完全合并到父图中，无缝集成。在这种模式下，父图和子图共享所有状态，子图就像是父图的一个扩展部分。
2.  编译添加：这种方式让子图和父图保持一定的独立性，只共享部分状态。适合需要一定独立性但又需要与主流程交互的场景。
3.  操作节点：可以自己定义子图和父图之间的交互逻辑，包括状态的转换、数据的传递等，最灵活。适合需要复杂交互逻辑的场景。

此处我们选择第 1 种，**子图父图状态可以完全共享**，因为子图不需要被复用。

这里我们可以编写一个新的工作流，使用 LangG⁠raph4j 的子图能力实现图片⁠收集的并发执行。这段代码仅供参考，实际未进行并发相关的配置，大家了解一下就好，不用自己实现。

```java
@Slf4j
public class CodeGenSubgraphWorkflow {

    /**
     * 创建内容图片收集子图
     */
    private StateGraph<MessagesState<String>> createContentImageSubgraph() {
        try {
            return new MessagesStateGraph<String>()
                    .addNode("content_collect", ContentImageCollectorNode.create())
                    .addEdge(START, "content_collect")
                    .addEdge("content_collect", END);
        } catch (GraphStateException e) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "内容图片子图创建失败");
        }
    }

    /**
     * 创建插画收集子图
     */
    private StateGraph<MessagesState<String>> createIllustrationSubgraph() {
        try {
            return new MessagesStateGraph<String>()
                    .addNode("illustration_collect", IllustrationCollectorNode.create())
                    .addEdge(START, "illustration_collect")
                    .addEdge("illustration_collect", END);
        } catch (GraphStateException e) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "插画子图创建失败");
        }
    }

    /**
     * 创建架构图生成子图
     */
    private StateGraph<MessagesState<String>> createDiagramSubgraph() {
        try {
            return new MessagesStateGraph<String>()
                    .addNode("diagram_generate", DiagramCollectorNode.create())
                    .addEdge(START, "diagram_generate")
                    .addEdge("diagram_generate", END);
        } catch (GraphStateException e) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "架构图子图创建失败");
        }
    }

    /**
     * 创建Logo生成子图
     */
    private StateGraph<MessagesState<String>> createLogoSubgraph() {
        try {
            return new MessagesStateGraph<String>()
                    .addNode("logo_generate", LogoCollectorNode.create())
                    .addEdge(START, "logo_generate")
                    .addEdge("logo_generate", END);
        } catch (GraphStateException e) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "Logo子图创建失败");
        }
    }

    /**
     * 创建子图工作流
     */
    public CompiledGraph<MessagesState<String>> createWorkflow() {
        try {
            // 获取各个未编译的子图（跟父图完全共享状态）
            StateGraph<MessagesState<String>> contentImageSubgraph = createContentImageSubgraph();
            StateGraph<MessagesState<String>> illustrationSubgraph = createIllustrationSubgraph();
            StateGraph<MessagesState<String>> diagramSubgraph = createDiagramSubgraph();
            StateGraph<MessagesState<String>> logoSubgraph = createLogoSubgraph();

            return new MessagesStateGraph<String>()
                    // 添加常规节点
                    .addNode("image_plan", ImagePlanNode.create())
                    .addNode("prompt_enhancer", PromptEnhancerNode.create())
                    .addNode("router", RouterNode.create())
                    .addNode("code_generator", CodeGeneratorNode.create())
                    .addNode("code_quality_check", CodeQualityCheckNode.create())
                    .addNode("project_builder", ProjectBuilderNode.create())
                    
                    // 添加编译后的子图作为节点
                    .addNode("content_image_subgraph", contentImageSubgraph)
                    .addNode("illustration_subgraph", illustrationSubgraph)
                    .addNode("diagram_subgraph", diagramSubgraph)
                    .addNode("logo_subgraph", logoSubgraph)
                    
                    // 添加图片聚合节点
                    .addNode("image_aggregator", ImageAggregatorNode.create())

                    // 添加边 - 串行部分
                    .addEdge(START, "image_plan")
                    
                    // 并发子图分支：从计划节点分发到各个子图
                    .addEdge("image_plan", "content_image_subgraph")
                    .addEdge("image_plan", "illustration_subgraph")
                    .addEdge("image_plan", "diagram_subgraph")
                    .addEdge("image_plan", "logo_subgraph")
                    
                    // 汇聚：所有子图都汇聚到聚合器
                    .addEdge("content_image_subgraph", "image_aggregator")
                    .addEdge("illustration_subgraph", "image_aggregator")
                    .addEdge("diagram_subgraph", "image_aggregator")
                    .addEdge("logo_subgraph", "image_aggregator")
                    
                    // 继续串行流程
                    .addEdge("image_aggregator", "prompt_enhancer")
                    .addEdge("prompt_enhancer", "router")
                    .addEdge("router", "code_generator")
                    .addEdge("code_generator", "code_quality_check")

                    // 质检条件边
                    .addConditionalEdges("code_quality_check",
                            edge_async(this::routeAfterQualityCheck),
                            Map.of(
                                    "build", "project_builder",
                                    "skip_build", END,
                                    "fail", "code_generator"
                            ))
                    .addEdge("project_builder", END)

                    .compile();
        } catch (GraphStateException e) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "子图工作流创建失败");
        }
    }

    /**
     * 路由函数：根据质检结果决定下一步
     */
    private String routeAfterQualityCheck(MessagesState<String> state) {
        WorkflowContext context = WorkflowContext.getContext(state);
        QualityResult qualityResult = context.getQualityResult();

        if (qualityResult == null || !qualityResult.getIsValid()) {
            log.error("代码质检失败，需要重新生成代码");
            return "fail";
        }

        log.info("代码质检通过，继续后续流程");
        CodeGenTypeEnum generationType = context.getGenerationType();
        if (generationType == CodeGenTypeEnum.VUE_PROJECT) {
            return "build";
        } else {
            return "skip_build";
        }
    }

    /**
     * 执行子图工作流
     */
    public WorkflowContext executeWorkflow(String originalPrompt) {
        CompiledGraph<MessagesState<String>> workflow = createWorkflow();

        WorkflowContext initialContext = WorkflowContext.builder()
                .originalPrompt(originalPrompt)
                .currentStep("初始化")
                .build();

        GraphRepresentation graph = workflow.getGraph(GraphRepresentation.Type.MERMAID);
        log.info("子图工作流图:\n{}", graph.content());
        log.info("开始执行子图代码生成工作流");

        WorkflowContext finalContext = null;
        int stepCounter = 1;
        for (NodeOutput<MessagesState<String>> step : workflow.stream(
                Map.of(WorkflowContext.WORKFLOW_CONTEXT_KEY, initialContext))) {
            log.info("--- 第 {} 步完成 ---", stepCounter);
            WorkflowContext currentContext = WorkflowContext.getContext(step.state());
            if (currentContext != null) {
                finalContext = currentContext;
                log.info("当前步骤上下文: {}", currentContext);
            }
            stepCounter++;
        }
        log.info("子图代码生成工作流执行完成！");
        return finalContext;
    }
}
```

创建单元测试：

```java
@SpringBootTest
class CodeGenSubgraphWorkflowTest {

    @Test
    void testSubgraphWorkflow() {
        WorkflowContext result = new CodeGenSubgraphWorkflow().executeWorkflow("创建一个在线学习平台，需要课程展示、视频播放和学习进度跟踪");
        Assertions.assertNotNull(result);
        System.out.println("生成类型: " + result.getGenerationType());
        System.out.println("生成的代码目录: " + result.getGeneratedCodeDir());
        System.out.println("构建结果目录: " + result.getBuildResultDir());
        System.out.println("收集的图片数量: " + (result.getImageList() != null ? result.getImageList().size() : 0));
    }

    @Test
    void testPortfolioWorkflow() {
        WorkflowContext result = new CodeGenSubgraphWorkflow().executeWorkflow("创建一个个人作品集网站，展示项目案例和技能介绍");
        Assertions.assertNotNull(result);
        System.out.println("生成类型: " + result.getGenerationType());
        System.out.println("生成的代码目录: " + result.getGeneratedCodeDir());
        System.out.println("收集的图片数量: " + (result.getImageList() != null ? result.getImageList().size() : 0));
    }
}
```

执行单元测试，发现成功搜集到⁠了多类图片，子父图⁠状态完全共享：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/HSUsD93DGnN4fyEG.webp "null")

#### 三种并发方案对比

最后，再给大家提供上述 3 种并发方案的对比表：



|方面|方案1 (CompletableFuture)|方案2 (LangGraph4j 并发)|方案3 (LangGraph4j 子图)|
|---|---|---|---|
|实现复杂度|中等|中等|高|
|可维护性|中等|高|最高|
|可重用性|低|中等|⁠最高|
|独立测试|难|中等|容易|
|状⁠态管理|手动|框架自动|框架自动|
|可视化|单节点|多节点|子图结构|
|团队协作|难|中等|最佳|

鱼皮的建议是，如果你的系统本身就是基于工作⁠流进行设计实现的，采用方案 ⁠2 或方案 3。子图尤其适合需要模块化开发的大型项目、或者需要复用某些工作流片段的场景。

如果你只是单纯为了实现并发，方案 1 就足够了。

### Studio

参考 [官方文档](https://langgraph4j.github.io/langgraph4j/studio/#use-spring-boot-implementation) 直接使用 Spring Boot 整合 Studio，可以实现运行 Langgraph4j 工作流的可视化交互和调试。

1）先引入依赖：

```xml
<!-- LangGraph4j Studio -->
<dependency>
    <groupId>org.bsc.langgraph4j</groupId>
    <artifactId>langgraph4j-studio-springboot</artifactId>
    <version>1.6.0-rc2</version>
</dependency>
```

2）然后在 `langgraph4j.config` 包下新建配置类，创建代码生成工作流的状态图，提供 LangGraphFlow 类型的 Bean 就好：

```java
@Configuration
public class LangGraphStudioSampleConfig extends AbstractLangGraphStudioConfig {

    final LangGraphFlow flow;

    public LangGraphStudioSampleConfig() throws GraphStateException {
        var workflow = new CodeGenWorkflow().createWorkflow().stateGraph;
        // define your workflow   
        this.flow = LangGraphFlow.builder()
                .title("LangGraph Studio")
                .stateGraph(workflow)
                .build();
    }

    @Override
    public LangGraphFlow getFlow() {
        return this.flow;
    }
}
```

3）启动项目并查看 Studio

这里有点坑，官方文档烂的一批⁠，甚至不愿意告诉我⁠ Studio 的访问地址在哪里！

我摸索了一番，发现访问后端根地址 `/api` 就能访问了，但默认会报错，因为请求接口的地址没有加 `/api` 前缀：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/Q7O8d3Faoz7WDHcd.webp "null")

临时注释配置文件的 `/api` 路径，查看实际效果：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/E1j486jIi1BJ9fR8.webp "null")

结果又是各种报错，我只能说目⁠前效果烂的一批，强⁠烈不推荐使用！还不如自己 Debug 调试。

### SSE 流式输出

之前我们已经通过 `workflow.stream` 获取到工作流的每一步内容，但如果想让某一个工作节点（比如网站生成）的内容也流式输出，就比较麻烦了。

官网虽然提供了 [SSE 支持](https://langgraph4j.github.io/langgraph4j/core/streaming/)，但是需要和 ChatModel 配合，并不灵活。

我的建议是使用 `SseEmitter` 或者自己构造 Flux 响应式数据流，比如每次执行工作流时新建 SseEmitter，通过它来灵活控制要输出什么内容。（方法的返回值可以是 SseEmitter）

下面给 2 种参考实现方案：

#### 推荐 - Flux 实现（因为兼容现有项目）

1）CodeGenWorkflow 工作流新增 ⁠SSE 输出版本的执行工作流方法⁠，自己构造 Flux 响应流：                                

```java
/**
 * 执行工作流（Flux 流式输出版本）
 */
public Flux<String> executeWorkflowWithFlux(String originalPrompt) {
    return Flux.create(sink -> {
        Thread.startVirtualThread(() -> {
            try {
                CompiledGraph<MessagesState<String>> workflow = createWorkflow();
                WorkflowContext initialContext = WorkflowContext.builder()
                        .originalPrompt(originalPrompt)
                        .currentStep("初始化")
                        .build();
                sink.next(formatSseEvent("workflow_start", Map.of(
                        "message", "开始执行代码生成工作流",
                        "originalPrompt", originalPrompt
                )));
                GraphRepresentation graph = workflow.getGraph(GraphRepresentation.Type.MERMAID);
                log.info("工作流图:\n{}", graph.content());

                int stepCounter = 1;
                for (NodeOutput<MessagesState<String>> step : workflow.stream(
                        Map.of(WorkflowContext.WORKFLOW_CONTEXT_KEY, initialContext))) {
                    log.info("--- 第 {} 步完成 ---", stepCounter);
                    WorkflowContext currentContext = WorkflowContext.getContext(step.state());
                    if (currentContext != null) {
                        sink.next(formatSseEvent("step_completed", Map.of(
                                "stepNumber", stepCounter,
                                "currentStep", currentContext.getCurrentStep()
                        )));
                        log.info("当前步骤上下文: {}", currentContext);
                    }
                    stepCounter++;
                }
                sink.next(formatSseEvent("workflow_completed", Map.of(
                        "message", "代码生成工作流执行完成！"
                )));
                log.info("代码生成工作流执行完成！");
                sink.complete();
            } catch (Exception e) {
                log.error("工作流执行失败: {}", e.getMessage(), e);
                sink.next(formatSseEvent("workflow_error", Map.of(
                        "error", e.getMessage(),
                        "message", "工作流执行失败"
                )));
                sink.error(e);
            }
        });
    });
}

/**
 * 格式化 SSE 事件的辅助方法
 */
private String formatSseEvent(String eventType, Object data) {
    try {
        String jsonData = JSONUtil.toJsonStr(data);
        return "event: " + eventType + "\ndata: " + jsonData + "\n\n";
    } catch (Exception e) {
        log.error("格式化 SSE 事件失败: {}", e.getMessage(), e);
        return "event: error\ndata: {\"error\":\"格式化失败\"}\n\n";
    }
}
```

2）编写工作流执行接口：

```java
/**
 * 工作流 SSE 控制器
 * 演示 LangGraph4j 工作流的流式输出功能
 */
@RestController
@RequestMapping("/workflow")
@Slf4j
public class WorkflowSseController {

    /**
     * 同步执行工作流
     */
    @PostMapping("/execute")
    public WorkflowContext executeWorkflow(@RequestParam String prompt) {
        log.info("收到同步工作流执行请求: {}", prompt);
        return new CodeGenWorkflow().executeWorkflow(prompt);
    }

    /**
     * Flux 流式执行工作流
     */
    @GetMapping(value = "/execute-flux", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> executeWorkflowWithFlux(@RequestParam String prompt) {
        log.info("收到 Flux 工作流执行请求: {}", prompt);
        return new CodeGenWorkflow().executeWorkflowWithFlux(prompt);
    }
}
```

3）编写一个用于测试的前端网站：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangGraph4j 工作流 SSE 演示</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .input-section {
            margin-bottom: 30px;
        }
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .button-group {
            margin: 20px 0;
            text-align: center;
        }
        button {
            padding: 12px 24px;
            margin: 0 10px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #545b62;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-success:hover {
            background-color: #1e7e34;
        }
        .output-section {
            margin-top: 30px;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.connecting {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .events {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        .event {
            margin-bottom: 15px;
            padding: 10px;
            border-left: 4px solid #007bff;
            background-color: white;
            border-radius: 3px;
        }
        .event-type {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }
        .event-data {
            font-family: 'Courier New', monospace;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            white-space: pre-wrap;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚀 LangGraph4j 工作流 SSE 演示</h1>
        
        <div class="input-section">
            <label for="promptInput">输入提示词：</label>
            <input type="text" id="promptInput" placeholder="例如：创建一个博客网站，包含文章列表和详情页面" 
                   value="创建一个在线教育平台，包含课程展示和学习进度跟踪功能">
        </div>
        
        <div class="button-group">
            <button class="btn-primary" onclick="startWorkflowFlux()">🔄 开始 Flux 工作流</button>
            <button class="btn-secondary" onclick="clearEvents()">🗑️ 清空日志</button>
        </div>
        
        <div class="output-section">
            <div id="status" class="status disconnected">状态: 未连接</div>
            <div class="events" id="events">
                <div class="event">
                    <div class="event-type">系统消息</div>
                    <div class="event-data">等待连接...</div>
                    <div class="timestamp">准备就绪</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;

        function updateStatus(message, className) {
            const status = document.getElementById('status');
            status.textContent = '状态: ' + message;
            status.className = 'status ' + className;
        }

        function addEvent(type, data, timestamp) {
            const events = document.getElementById('events');
            const event = document.createElement('div');
            event.className = 'event';
            
            const eventType = document.createElement('div');
            eventType.className = 'event-type';
            eventType.textContent = type;
            
            const eventData = document.createElement('div');
            eventData.className = 'event-data';
            eventData.textContent = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
            
            const eventTime = document.createElement('div');
            eventTime.className = 'timestamp';
            eventTime.textContent = timestamp || new Date().toLocaleTimeString();
            
            event.appendChild(eventType);
            event.appendChild(eventData);
            event.appendChild(eventTime);
            
            events.appendChild(event);
            events.scrollTop = events.scrollHeight;
        }

        function startWorkflowFlux() {
            const prompt = document.getElementById('promptInput').value.trim();
            if (!prompt) {
                alert('请输入提示词');
                return;
            }
            
            if (eventSource) {
                eventSource.close();
            }
            
            updateStatus('工作流执行中...', 'connecting');
            addEvent('系统消息', '开始执行工作流: ' + prompt, new Date().toLocaleTimeString());
            
            const url = `http://localhost:8123/api/workflow/execute-flux?prompt=${encodeURIComponent(prompt)}`;
            eventSource = new EventSource(url);
            
            eventSource.onopen = function() {
                updateStatus('工作流连接已建立', 'connected');
                addEvent('连接事件', '工作流 Flux 连接成功建立', new Date().toLocaleTimeString());
                console.log('EventSource 连接已建立');
            };
            
            // 通用消息监听器，捕获所有事件
            eventSource.onmessage = function(event) {
                console.log('收到通用消息:', event);
                try {
                    const data = JSON.parse(event.data);
                    addEvent('📨 通用消息', data, new Date().toLocaleTimeString());
                } catch (e) {
                    addEvent('📨 通用消息', event.data, new Date().toLocaleTimeString());
                }
            };
            
            eventSource.addEventListener('workflow_start', function(event) {
                console.log('收到 workflow_start 事件:', event.data);
                const data = JSON.parse(event.data);
                addEvent('🚀 工作流开始', data, new Date().toLocaleTimeString());
            });
            
            eventSource.addEventListener('step_completed', function(event) {
                console.log('收到 step_completed 事件:', event.data);
                const data = JSON.parse(event.data);
                addEvent(`✅ 步骤 ${data.stepNumber} 完成: ${data.currentStep}`, data, new Date().toLocaleTimeString());
            });
            
            eventSource.addEventListener('workflow_completed', function(event) {
                const data = JSON.parse(event.data);
                addEvent('🎉 工作流完成', data, new Date().toLocaleTimeString());
                setTimeout(() => {
                    eventSource.close();
                    updateStatus('工作流完成，连接已关闭', 'disconnected');
                }, 1000);
            });
            
            eventSource.addEventListener('workflow_error', function(event) {
                const data = JSON.parse(event.data);
                addEvent('❌ 工作流错误', data, new Date().toLocaleTimeString());
                setTimeout(() => {
                    eventSource.close();
                    updateStatus('工作流失败，连接已关闭', 'disconnected');
                }, 1000);
            });
            
            eventSource.onerror = function(event) {
                console.error('EventSource 错误:', event);
                updateStatus('连接错误', 'disconnected');
                addEvent('错误事件', '工作流连接发生错误', new Date().toLocaleTimeString());
                eventSource.close();
            };
        }

        function clearEvents() {
            const events = document.getElementById('events');
            events.innerHTML = '<div class="event"><div class="event-type">系统消息</div><div class="event-data">日志已清空</div><div class="timestamp">' + new Date().toLocaleTimeString() + '</div></div>';
        }

        // 页面卸载时关闭连接
        window.addEventListener('beforeunload', function() {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>
```

效果如图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/GOATxnlE823ozLtm.webp)

#### 扩展知识 - SseEmitter 实现

1）CodeGenWorkfl⁠ow 工作流新增 S⁠SE 输出版本的执行工作流方法，返回值为 SseEmitter：

```java
/**
 * 执行工作流（SSE 流式输出版本）
 */
public SseEmitter executeWorkflowWithSse(String originalPrompt) {
    SseEmitter emitter = new SseEmitter(30 * 60 * 1000L);
    Thread.startVirtualThread(() -> {
        try {
            CompiledGraph<MessagesState<String>> workflow = createWorkflow();
            WorkflowContext initialContext = WorkflowContext.builder()
                    .originalPrompt(originalPrompt)
                    .currentStep("初始化")
                    .build();
            sendSseEvent(emitter, "workflow_start", Map.of(
                    "message", "开始执行代码生成工作流",
                    "originalPrompt", originalPrompt
            ));
            GraphRepresentation graph = workflow.getGraph(GraphRepresentation.Type.MERMAID);
            log.info("工作流图:\n{}", graph.content());

            int stepCounter = 1;
            for (NodeOutput<MessagesState<String>> step : workflow.stream(
                    Map.of(WorkflowContext.WORKFLOW_CONTEXT_KEY, initialContext))) {
                log.info("--- 第 {} 步完成 ---", stepCounter);
                WorkflowContext currentContext = WorkflowContext.getContext(step.state());
                if (currentContext != null) {
                    sendSseEvent(emitter, "step_completed", Map.of(
                            "stepNumber", stepCounter,
                            "currentStep", currentContext.getCurrentStep()
                    ));
                    log.info("当前步骤上下文: {}", currentContext);
                }
                stepCounter++;
            }
            sendSseEvent(emitter, "workflow_completed", Map.of(
                    "message", "代码生成工作流执行完成！"
            ));
            log.info("代码生成工作流执行完成！");
            emitter.complete();
        } catch (Exception e) {
            log.error("工作流执行失败: {}", e.getMessage(), e);
            sendSseEvent(emitter, "workflow_error", Map.of(
                    "error", e.getMessage(),
                    "message", "工作流执行失败"
            ));
            emitter.completeWithError(e);
        }
    });
    return emitter;
}

/**
 * 发送 SSE 事件的辅助方法
 */
private void sendSseEvent(SseEmitter emitter, String eventType, Object data) {
    try {
        emitter.send(SseEmitter.event()
                .name(eventType)
                .data(data));
    } catch (IOException e) {
        log.error("发送 SSE 事件失败: {}", e.getMessage(), e);
    }
}
```

2）新增一个 SSE 工作流接口：

```java
/**
 * 工作流 SSE 控制器
 * 演示 LangGraph4j 工作流的流式输出功能
 */
@RestController
@RequestMapping("/workflow")
@Slf4j
public class WorkflowSseController {

    /**
     * 同步执行工作流
     */
    @PostMapping("/execute")
    public WorkflowContext executeWorkflow(@RequestParam String prompt) {
        log.info("收到同步工作流执行请求: {}", prompt);
        return new CodeGenWorkflow().executeWorkflow(prompt);
    }

    /**
     * SSE 流式执行工作流
     */
    @GetMapping(value = "/execute-sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter executeWorkflowWithSse(@RequestParam String prompt) {
        log.info("收到 SSE 工作流执行请求: {}", prompt);
        return new CodeGenWorkflow().executeWorkflowWithSse(prompt);
    }
}
```

3）用 AI 生成工作流演示 Demo 网站：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangGraph4j 工作流 SSE 演示</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .input-section {
            margin-bottom: 30px;
        }
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .button-group {
            margin: 20px 0;
            text-align: center;
        }
        button {
            padding: 12px 24px;
            margin: 0 10px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #545b62;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-success:hover {
            background-color: #1e7e34;
        }
        .output-section {
            margin-top: 30px;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.connecting {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .events {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        .event {
            margin-bottom: 15px;
            padding: 10px;
            border-left: 4px solid #007bff;
            background-color: white;
            border-radius: 3px;
        }
        .event-type {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }
        .event-data {
            font-family: 'Courier New', monospace;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            white-space: pre-wrap;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚀 LangGraph4j 工作流 SSE 演示</h1>
        
        <div class="input-section">
            <label for="promptInput">输入提示词：</label>
            <input type="text" id="promptInput" placeholder="例如：创建一个博客网站，包含文章列表和详情页面" 
                   value="创建一个在线教育平台，包含课程展示和学习进度跟踪功能">
        </div>
        
        <div class="button-group">
            <button class="btn-primary" onclick="startWorkflowSse()">🔄 开始 SSE 工作流</button>
            <button class="btn-secondary" onclick="clearEvents()">🗑️ 清空日志</button>
        </div>
        
        <div class="output-section">
            <div id="status" class="status disconnected">状态: 未连接</div>
            <div class="events" id="events">
                <div class="event">
                    <div class="event-type">系统消息</div>
                    <div class="event-data">等待连接...</div>
                    <div class="timestamp">准备就绪</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;

        function updateStatus(message, className) {
            const status = document.getElementById('status');
            status.textContent = '状态: ' + message;
            status.className = 'status ' + className;
        }

        function addEvent(type, data, timestamp) {
            const events = document.getElementById('events');
            const event = document.createElement('div');
            event.className = 'event';
            
            const eventType = document.createElement('div');
            eventType.className = 'event-type';
            eventType.textContent = type;
            
            const eventData = document.createElement('div');
            eventData.className = 'event-data';
            eventData.textContent = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
            
            const eventTime = document.createElement('div');
            eventTime.className = 'timestamp';
            eventTime.textContent = timestamp || new Date().toLocaleTimeString();
            
            event.appendChild(eventType);
            event.appendChild(eventData);
            event.appendChild(eventTime);
            
            events.appendChild(event);
            events.scrollTop = events.scrollHeight;
        }

        function startWorkflowSse() {
            const prompt = document.getElementById('promptInput').value.trim();
            if (!prompt) {
                alert('请输入提示词');
                return;
            }
            
            if (eventSource) {
                eventSource.close();
            }
            
            updateStatus('工作流执行中...', 'connecting');
            addEvent('系统消息', '开始执行工作流: ' + prompt, new Date().toLocaleTimeString());
            
            const url = `http://localhost:8123/api/workflow/execute-sse?prompt=${encodeURIComponent(prompt)}`;
            eventSource = new EventSource(url);
            
            eventSource.onopen = function() {
                updateStatus('工作流连接已建立', 'connected');
                addEvent('连接事件', '工作流 SSE 连接成功建立', new Date().toLocaleTimeString());
            };
            
            eventSource.addEventListener('workflow_start', function(event) {
                const data = JSON.parse(event.data);
                addEvent('🚀 工作流开始', data, new Date().toLocaleTimeString());
            });
            
            eventSource.addEventListener('step_completed', function(event) {
                const data = JSON.parse(event.data);
                addEvent(`✅ 步骤 ${data.stepNumber} 完成: ${data.currentStep}`, data, new Date().toLocaleTimeString());
            });
            
            eventSource.addEventListener('workflow_completed', function(event) {
                const data = JSON.parse(event.data);
                addEvent('🎉 工作流完成', data, new Date().toLocaleTimeString());
                setTimeout(() => {
                    eventSource.close();
                    updateStatus('工作流完成，连接已关闭', 'disconnected');
                }, 1000);
            });
            
            eventSource.addEventListener('workflow_error', function(event) {
                const data = JSON.parse(event.data);
                addEvent('❌ 工作流错误', data, new Date().toLocaleTimeString());
                setTimeout(() => {
                    eventSource.close();
                    updateStatus('工作流失败，连接已关闭', 'disconnected');
                }, 1000);
            });
            
            eventSource.onerror = function(event) {
                updateStatus('连接错误', 'disconnected');
                addEvent('错误事件', '工作流连接发生错误', new Date().toLocaleTimeString());
                eventSource.close();
            };
        }

        function clearEvents() {
            const events = document.getElementById('events');
            events.innerHTML = '<div class="event"><div class="event-type">系统消息</div><div class="event-data">日志已清空</div><div class="timestamp">' + new Date().toLocaleTimeString() + '</div></div>';
        }

        // 页面卸载时关闭连接
        window.addEventListener('beforeunload', function() {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>
```

测试运行，效果如图：

![](https://pic.code-nav.cn/course_picture/1608440217629360130/T7xp4ehuUmfu5jpq.webp)

#### 扩展思路

在实际应用中，大家可以根据业务需求⁠灵活选择 SSE 输出⁠的内容，比如实时推送搜集到的图片信息、代码生成进度或者质量检查结果。

如果想要实现更细粒度的实时反馈，还可以考虑将 SseEmitter 传递⁠到具体的工作节点内部，让每个节点都能直接输出处理⁠状态。可以通过 ThreadLocal 在同一线程内传递 SseEmitter 对象，或者将其作为状态的一部分在节点间传递来实现。

## 扩展思路 - 和现有业务整合

虽然开篇提到了，这是另一种实现模式；但如果一定要整合，其实也不麻烦，**但是我不建议大家实现，使用之前的模式就够了。**

以下仅为参考，实际要修改的内容可能会更多。

### 后端修改

复用原有对话接口成本最低，只需⁠要把原本调用 AI ⁠门面生成代码改为根据生成模式选择使用工作流还是 AI 门面即可。

#### 1、WorkflowContext 支持 appId

添加了 appId 字段，默认值为 0L

```java
/**
 * 应用 ID
 */
private Long appId = 0L;
```

#### 2、CodeGenWorkflow 支持 appId 参数

-   参数变更为 executeWorkflowWithFlux(String, Long) - 流式版本
-   初始化时将 appId 传递到 WorkflowContext
-   提供一个兼容不传 appId 的方法

代码如下：

```java
/**
 * 执行工作流（Flux 流式输出版本）
 */
public Flux<String> executeWorkflowWithFlux(String originalPrompt, Long appId) {
    return Flux.create(sink -> {
        Thread.startVirtualThread(() -> {
            try {
                CompiledGraph<MessagesState<String>> workflow = createWorkflow();
                WorkflowContext initialContext = WorkflowContext.builder()
                        .appId(appId)
                        .originalPrompt(originalPrompt)
                        .currentStep("初始化")
                        .build();
                // ...
            }
        })
    })
}

/**
 * 执行工作流（Flux 流式输出版本）
 */
public Flux<String> executeWorkflowWithFlux(String originalPrompt) {
    return executeWorkflowWithFlux(originalPrompt, 0L);
}
```

#### 3、AppService 接口增加 agent 参数

-   参数变更为 chatToGenCode(Long, String, User, Boolean)
-   agent 参数默认为 false，可选传入

代码如下：

```java
/**
 * 应用聊天生成代码（流式）
 *
 * @param appId   应用 ID
 * @param message 用户消息
 * @param loginUser 登录用户
 * @param agent 是否启用 Agent 模式
 * @return 生成的代码流
 */
Flux<String> chatToGenCode(Long appId, String message, User loginUser, boolean agent);
```

#### 4、AppServiceImpl 实现 agent 模式切换

代码如下：

```java
// 6. 根据 agent 参数选择生成方式
Flux<String> codeStream;
if (agent) {
    // Agent 模式：使用工作流生成代码
    codeStream = new CodeGenWorkflow().executeWorkflowWithFlux(message, appId);
} else {
    // 传统模式：调用 AI 生成代码（流式）
    codeStream = aiCodeGeneratorFacade.generateAndSaveCodeStream(message, codeGenTypeEnum, appId);
}
```

#### 5、AppController 支持 agent 参数

-   添加请求参数
-   调用时传递 agent 参数到服务层

代码如下：

```java
public Flux<ServerSentEvent<String>> chatToGenCode(
    @RequestParam Long appId,
    @RequestParam String message,
    @RequestParam(defaultValue = "false") boolean agent,
    HttpServletRequest request){}

// 调用服务生成代码（流式）
Flux<String> contentFlux = appService.chatToGenCode(appId, message, loginUser, agent);
```

#### 6、工具兼容

CodeGeneratorN⁠ode 补充获取 ⁠appId 的逻辑：

```java
// 获取 appId
Long appId = context.getAppId();
```

### 前端修改

前端可以新增 agent 模式，传递 `agent = true`。

重新执行 openAPI 工⁠具，测试时先修改生⁠成代码的参数：

```typescript
// 构建URL参数
const params = new URLSearchParams({
  appId: appId.value || '',
  message: userMessage,
  agent: "true",
})

const url = `${baseURL}/app/chat/gen/code?${params}`
```

需要根据自己的需要修改前后端传递的参数，以达到更好的效果。

不过目前还不是深度整合，其实应该在工作流中⁠设置 app 的 codeG⁠enEnum、保存用户的对话记录等等，但这样整个流程都要发生进一步变化，没有必要了。

而且工作流目前没有区分新建和⁠修改，如果是修改的⁠话，不需要重复搜图、增强提示词等步骤。

## 总结

在这一节中，我们深入学习了 AI 工作流的概念和实⁠现。通过 LangGraph4j 框⁠架，我们不仅重构了一套新的代码生成逻辑，还为系统增加了智能图片收集功能，让生成的网站更加真实生动。


